fsck 内存映射
视频解密 nginx
onvif rstp
火警检测 
升级md5校验

例如，如果要将名为 myfolder 的文件夹打包成 myfolder.tar.gz 文件，可以使用以下命令：

tar -czvf myfolder.tar.gz myfolder

vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other
tar -zcvf include.tar.gz include/
tar -xzf
tar -xzf /bbs.tar.zip -C /zzz/bbs
unzip pwdecrypt.zip -d ./pwdecrypt/ 
rm -rf !(keep) #删除keep文件之外的所有文件

解压xxxxx.tar.gz 会将里面的yyyyy文件夹解压在当前目录
tar -xzf xxxxx.tar.gz 

zip -r html.zip ./html

bash: !: event not found
原因：未开启扩展通配符

shopt使用
shopt [-psu] [optname …]

-s 开启某个选项。
-u 关闭某个选项。
-p 列出所有可设置的选项。

查看扩展通配符是否开启：shopt extglob
开启扩展通配符：shopt -s  extglob

sutt
tt

root
puwell007

touch /config/debug.sh
rm /config/debug.sh

sd卡：
/media
nfs:


/usr/bin 
zrt_app daemon_app

根目录
cd /

find / -name "zrt_app"

find / -name "*_app" | grep "zrt"

root@mars-virtual-machine:/home/mars/.ssh# id
uid=0(root) gid=0(root) groups=0(root)

gedit /etc/exports

/home/mars/nfs_share 192.168.0.0/24(rw,sync,all_squash,anonuid=1000,anongid=1000,no_subtree_check)

/home/mars/nfs_share：要共享的开发主机目录
192.168.0.0/24：配置谁可以访问，其中的/24 是掩码
rw: 表示客户机的权限，rw 表示可读写
sync：资料同步写入到内存与硬盘中。
anonuid=1000：将客户机上的用户映射成指定的本地用户 ID 的用户
anongid=998： 将客户机上的用户映射成属于指定的本地用户组 ID
no_subtree_check：不检查子目录权限，默认配置
————————————————
版权声明：本文为CSDN博主「田三番」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_27961843/article/details/103325967

修改完/etc/exports文件并保存后，可使用exportfs命令更新配置：
#以下命令在主机上运行
sudo exportfs -arv

showmount -e

计算字符串"hello"的md5
echo -n "hello" | md5sum

测试：
mount -t nfs localhost:/home/mars/nfs_share /mnt

chmod -R 777 /mnt

drwxr-x--- 该权限分为4个部分d、rwx、r-x、---。

d:表示文件类型；

rwx：表示文件所有者的对该文件所拥有的权限；

r-x：表示文件所属组对该文件所拥有的权限；

---：表示其他用户对该文件所拥有的权限。

chmod -R 755 该命令表示文件所有者有读写执行权限（4+2+1）、文件所属组有读执行权限（4+1）、其他人有读执行权限（4+1）。

changing permissions of '/usr': Read-only file system
如果是系统文件出现这个问题，重新挂载根目录即可：
mount -rw -o remount /usr

查看 NFS 共享情况
showmount -e

清空屏幕快捷键：
ctrl + l 

清空当前输入快捷键：
ctrl + u

udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share

cp zrt_app /home/mars/nfs_share/zrt_app
cp zrt_app.debug /home/mars/nfs_share/dbg_zrt_app

/tmp/nfs_share/zrt_app &
rm -rf coredump_*

mount -o vers=4 192.168.99.193:/extern/nfs_media /media


com3

115200

udhcpc 设备获取ip

route add 192.168.5.0 mask 255.255.255.0 192.168.2.254 if 24 -p

在这个例子中：

192.168.5.0表示目标网段；

mask后面接掩码，255.255.255.0表示目标网段的掩码；

192.168.2.254表示路由的下一跳地址，也就是，想要到达192.168.5.0的数据，本机都会发给192.168.2.254去转发；

if后面接本机的网卡接口号，如果本机有多个网卡，那么就需要区分你想要用哪个网卡去访问目标网段，这里的接口号就是开头说的通过route print命令查看到的。

例如我的24号接口能够通到目标网段，那么这里就输入24；

“-p”这个参数表示该条路由永久生效。如果不加这个参数，那么需要注意，你的这条路由在本机重启后将会失效。

route delete 192.168.19.0 mask 255.255.255.0

route add 192.168.19.0 mask 255.255.255.0 192.168.19.1 if 7 -p
相机99.186想要连接虚拟机19.129 就让网关19.1 转发

linux route命令
#添加一条路由(发往192.168.62这个网段的全部要经过网关192.168.1.1)
route add -net 192.168.62.0 netmask 255.255.255.0 gw 192.168.1.1

#删除一条路由　删除的时候不用写网关
route del -net 192.168.122.0 netmask 255.255.255.0

route add -net 192.168.19.0 netmask 255.255.255.0 gw 192.168.99.224

route add 192.168.19.0 mask 255.255.255.0 0.0.0.0 if 7 -p

开发板要ping通虚拟机，与其设置各种路由，不如让虚拟机和开发置于同一个路由网段下，设置虚拟机的网络配置器为 桥接模式

newifi_b889  puwell007

	
g++ -v -E -x c++ -

/home/mars/test/.vscode/c_cpp_properties.json

                "/usr/include/c++/11",
                "/usr/include/x86_64-linux-gnu/c++/11",
                "/usr/include/c++/11/backward",
                "/usr/lib/gcc/x86_64-linux-gnu/11/include",
                "/usr/local/include",
                "/usr/include/x86_64-linux-gnu",
                "/usr/include"


1. vscode全局搜索 (可搜代码，文件等)

Windows:

Ctrl+Shift+F

怎么调试，能用断点吗还是只能靠日志理解调用顺序
日志是哪个路径？

cp /tmp/log/host.log.bak /tmp/nfs_share/zrtx.log
cp /media/log/host.log1 /tmp/nfs_share/zrtx.log

export LD_LIBRARY_PATH=/media/usr/lib:$LD_LIBRARY_PATH
./usr/bin/gdb  zrt_app_debug

export LD_LIBRARY_PATH=/tmp/nfs_share/allwinner_gdb/usr/lib:$LD_LIBRARY_PATH
/tmp/nfs_share/allwinner_gdb/usr/bin/gdb -e zrt_app -s dbg_zrt_app -c coredump

chmod -R 777 /tmp/nfs_share/

 1 编译
gcc -g -o foo foo.c

2 生成单独的调试信息文件
objcopy --only-keep-debug foo foo.dbg

3 去除调试信息
objcopy --strip-debug --strip-unneeded foo

加载分离的符号表调试  
gdb -e foo -s foo.dbg


ZRT_MgrSignIn  ZRT_CLD_Obj()

ZRT_MgrMsgProc ZRT_MEDIA_Obj()

top
ps aux|grep 2761 #2761是PID值

C:\Users\admin\AppData\Roaming\Subversion
# enable-auto-props = no

调用全志api取帧发送到队列
ZRT_GetEncStreamThread
AW_MPI_VENC_GetStream
ZRT_StreamProc
ZRT_MEDIA_VIDEO_SEND
ZRT_Msg_SendInstantMsg
ZRT_MEDIA_VideoSend_Proc
ZRT_Queue_AddToTail

从队列取帧存卡、云、推流
ZRT_VideoPackAndSend
ZRT_GetFrame

./configure CC="/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc" --host=arm-openwrt-linux-muslgnueabi --prefix=$PWD/build
./configure --prefix=$PWD/build

./configure CC="/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc" --host=arm-openwrt-linux-muslgnueabi --prefix=$PWD/build CFLAGS=-static

./configure CC="/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc" --host=arm-openwrt-linux-muslgnueabi --prefix=$PWD/build CFLAGS=-static LDFLAGS="-L/extern/v853/out/v851se-perf1/staging_dir/target/usr/lib/"



升级固件 把固件PUWELL_PA_Q851SE+8188_16M_V7.02.81_20230802.bin改名为gbl_rootfs.bin，放到sd卡里，启动Daemon
/media/gbl_rootfs.bin
/usr/bin/Daemon_app &

umount /media
./fsck.fat -awy /dev/mmcblk0p1 &
mount  /dev/mmcblk0p1  /media

/tmp/nfs_share/dosfstools-4.2/build/sbin/fsck.fat -a /dev/mmcblk0p1 &


udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share

        sleep 17
        echo "iperf start"
        /media/iperf3/iperf_run.sh &


/tmp/nfs_share/dosfstools-4.2/build/sbin/fsck.fat -a /dev/mmcblk0p1

df -h 查看磁盘容量

fsck.fat32.project-main
Usage: ./myfsck <options> <disk_name>
options:
-i: show all information
-s: show only reserved sectors
-f: show only files

另外两个编译不过

查看环境变量
export

winhex

sc create svnservice binpath="C:\install\svn\bin\svnserve.exe --service -r C:\svn_repo" depend=Tcpip start=auto
sc delete svnservice

services.msc
svn://192.168.99.224

svn checkout svn://192.168.99.224/dostool_fsck --username mars --password tt
svn checkout svn://192.168.99.224/dostool_fsck ./fsck_bk --username mars --password tt #检出到指定的fsck_bk目录
svn checkout https://192.168.10.195:448/svn/Qz-IPC/trunk/tina-v853 ./v853 --username zhongxt --password 123456
svn export https://192.168.10.195:448/svn/Qz-IPC/trunk/tina-v853 ./v853 --username zhongxt --password 123456

svn checkout svn://192.168.10.246/server/Qz-SDK ./qzsdk --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libonvif ./onvif --username zhongxt --password 123456

svn checkout https://192.168.10.195:448/svn/ipc/trunk/librtsp/LIBRTSPRTP_V1.0.0.0_R20130603 ./rtsplib --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libhttp/LIBHTTP_V1.0.0.0_R20130603 ./http --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libinfra/LIBINFRA_V1.0.0.0_R20130603 ./thread_and_mutex --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libstream_reader/LIBSTREAMREADER_V1.0.0.0_R20130603 ./stream_reader --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libtpbase/LIBTPBASE_V1.0.0.0_R20130603 ./tpbase --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libtpbase_x/LIBTPBASE_X_V1.0.0.0_R20190306 ./tpbase_x --username zhongxt --password 123456

svn checkout svn://192.168.10.246/server/Qz-SDK ./packapp --username zhongxt --password 123456


将一个文件夹下的所有内容复制到另一个文件夹下
cp -r /home/packageA/* /home/cp/packageB/


在/etc/profile文件中添加变量【对所有用户生效（永久的）】  

用vim在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。  

例如 增加下列变量
export wksp=/home/mars/workspace
export mars=/home/mars
export nfss=/home/mars/nfs_share
export qz_toolchain=/home/mars/workspace/code/Qz-SDK/cross_compiler/toolchain

要让刚才的修改马上生效，需要执行以下代码  
source /etc/profile  

删除环境变量:
unset xxxxx

pidof 程序名称（进程名） 查看某一程序的进程号
ps -aux | grep redis 查看redis 进程信息
ps -eo pid,comm,rss,vsz |grep 进程名  (其中-rss和-vsz分别是该 进程 所 占用 的实际 内存 和虚拟 内存 大小，单位是KB。)

cat >test 创建test文件 ctrl+D退出

svn up -r3 回退到3版本
svn up 更新到最新版本
svn 远端根目录新增了一个文件夹，我只想把这个文件夹更新下来，应该怎么做?
要将远程仓库中新增的特定文件夹更新到本地，您可以使用以下命令：

svn update new_dir

valgrind --tool=memcheck --leak-check=full ./fsck.fat -a check-bad_names.img 检测内存泄漏

sh -x xxxx.sh param1 param2 调试sh脚本

qt安装器下载 https://www.qt.io/download-qt-installer-oss?hsCtaTracking=99d9dd4f-5681-48d2-b096-470725510d34%7C074ddad0-fdef-4e53-8aa8-5e8a876d6ab4

linux 安装qt
运行这个 qt-unified-linux-x64-4.6.0-online.run，缺库就安装库

linux QT 开发 要cmake能找到qt的组件，需要安装下面两个库
apt-get install build-essential libgl1-mesa-dev

cmake -DCMAKE_PREFIX_PATH=/opt/Qt/6.5.1/gcc_64 ..

安装ffmpeg
1、下载解压

wget http://www.ffmpeg.org/releases/ffmpeg-3.1.tar.gz
tar -zxvf ffmpeg-3.1.tar.gz 
2、 进入解压后目录,输入如下命令/usr/local/ffmpeg为自己指定的安装目录

cd ffmpeg-3.1
./configure --prefix=/usr/local/ffmpeg
make && make install

wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz
tar -zxvf yasm-1.3.0.tar.gz
cd yasm-1.3.0
./configure
make && make install

cmake -DCMAKE_CXX_COMPILER=C:\mingw64\bin\g++ -DCMAKE_C_COMPILER=C:\mingw64\bin\gcc 

"C:\Program Files\CMake\bin\cmake.exe" --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=C:\msys64\mingw64\bin\gcc.exe -DCMAKE_CXX_COMPILER:FILEPATH=C:\msys64\mingw64\bin\g++.exe -SC:/workspace/pwdecrypt -Bc:/workspace/pwdecrypt/build -G "MinGW Makefiles" -DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64
-DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64

"C:\Program Files\CMake\bin\cmake.exe" --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\gcc.exe -DCMAKE_CXX_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\g++.exe -SC:/workspace/pwdecrypt -Bc:/workspace/pwdecrypt/build -G "MinGW Makefiles" -DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64

"C:\Program Files\CMake\bin\cmake.exe" --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Release -DCMAKE_C_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\gcc.exe -DCMAKE_CXX_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\g++.exe -SC:/workspace/pwdecrypt -Bc:/workspace/pwdecrypt/build -G "MinGW Makefiles" -DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64
windows 安装新版的mingw
先安装msys2 
然后设置源
然后 pacman -S --needed base-devel mingw-w64-x86_64-toolchain 


C:\Qt\Tools\CMake_64\bin\cmake.exe -S C:/workspace/pwdecrypt1 -B C:/workspace/pwdecrypt1/build "-DCMAKE_GENERATOR:STRING=Ninja" "-DCMAKE_BUILD_TYPE:STRING=Debug" "-DCMAKE_PROJECT_INCLUDE_BEFORE:FILEPATH=C:/workspace/pwdecrypt1/build.qtc/package-manager/auto-setup.cmake" "-DQT_QMAKE_EXECUTABLE:FILEPATH=C:/Qt/6.5.1/mingw_64/bin/qmake.exe" "-DCMAKE_PREFIX_PATH:PATH=C:/Qt/6.5.1/mingw_64" "-DCMAKE_C_COMPILER:FILEPATH=C:/Qt/Tools/mingw1120_64/bin/gcc.exe" "-DCMAKE_CXX_COMPILER:FILEPATH=C:/Qt/Tools/mingw1120_64/bin/g++.exe" "-DCMAKE_CXX_FLAGS_INIT:STRING=-DQT_QML_DEBUG" 

fdisk -l
lsblk


/dev/sdb

/home/mars/svn_workspace/fsck_bk/build/sbin


udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share
cd /tmp/nfs_share/scripts
./first


udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share
cd /tmp/nfs_share/scripts
./second


./configure --prefix=/server/nginx --with-http_ssl_module --with-http_sub_module --add-module=../nginx-upload-module-2.3.0

apt-get install libpcre3-dev  #pcre 错误
apt-get install libssl-dev   #openssl 错误
apt-get install zlib1g-dev

chmod 666 file/folder 表示所有用户都可以读写但不能执行文件/文件夹;
chmod 777 file/folder 允许所有用户的所有操作(一般的暴力解决办法)
chmod 744 file/folder 只允许用户(所有者)执行所有操作;组和其他用户只允许阅读。


nginx -s reload

location / {
            root   C:\Uploads;
            autoindex on;                            
			autoindex_exact_size off;            
			autoindex_localtime on;            
        }

location /upload {
            # Pass altered request body to this location
            #upload_pass   @test;

            # Store files to this directory
            # The directory is hashed, subdirectories 0 1 2 3 4 5 6 7 8 9 should exist
            upload_store /upfiles 1;
            
            # Allow uploaded files to be read only by user
            upload_store_access user:r;

            # Set specified fields in request body
            upload_set_form_field "${upload_field_name}_name" $upload_file_name;
            upload_set_form_field "${upload_field_name}_content_type" $upload_content_type;
            upload_set_form_field "${upload_field_name}_path" $upload_tmp_path;

            # Inform backend about hash and size of a file
            upload_aggregate_form_field "${upload_field_name}_md5" $upload_file_md5;
            upload_aggregate_form_field "${upload_field_name}_size" $upload_file_size;

            upload_pass_form_field "^submit$|^description$";
        }

        # Pass altered request body to a backend
        location @test {
            proxy_pass   http://localhost:8288;
        }


        location /upload {
            # Pass altered request body to this location
            upload_pass   /example.php;

            # Store files to this directory
            # The directory is hashed, subdirectories 0 1 2 3 4 5 6 7 8 9 should exist
            upload_store /upfiles 1;
            
            # Allow uploaded files to be read only by user
            upload_store_access user:r;

            # Set specified fields in request body
            upload_set_form_field "${upload_field_name}_name" $upload_file_name;
            upload_set_form_field "${upload_field_name}_content_type" $upload_content_type;
            upload_set_form_field "${upload_field_name}_path" $upload_tmp_path;

            # Inform backend about hash and size of a file
            upload_aggregate_form_field "${upload_field_name}_md5" $upload_file_md5;
            upload_aggregate_form_field "${upload_field_name}_size" $upload_file_size;

            upload_pass_form_field "^submit$|^description$";
        }

        # Pass altered request body to a backend
        #location @test {
        #    proxy_pass   http://localhost:8080;
        #}
        location ~ \.php$ {
     		root           html/upload;
     	  	fastcgi_pass   127.0.0.1:9000;
     		fastcgi_index  index.php;
	        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        	include        fastcgi_params;
  	  }


ps -aux | grep nginx


var http = require('http'); 
var fs = require('fs'); 
var formidable = require('formidable'); 
 
// 包含上传表单的html文件
var upload_html = fs.readFileSync("/server/nginx/html/upload.html"); 
 
// 将其替换为保存上传文件的位置
var upload_path = "/upfiles/"; 
 
http.createServer(function (req, res) { 
    if (req.url == '/uploadform') { 
      res.writeHead(200); 
      res.write(upload_html); 
      return res.end(); 
    } else if (req.url == '/fileupload') { 
        var form = new formidable.IncomingForm(); 
        form.parse(req, function (err, fields, files) { 
            // oldpath：文件保存到的临时文件夹
            var oldpath = files.filetoupload.filepath; 
            var newpath = upload_path + files.filetoupload.name; 
            // 将文件复制到新位置
            fs.rename(oldpath, newpath, function (err) { 
                if (err) throw err; 
                // 您可能会用另一个html页面进行响应
                res.write('File uploaded and moved!'); 
                res.end(); 
            }); 
        }); 
    }  
 }).listen(8086);


curl 192.168.99.224:80/xxfcgi -F "file=@/home/mars/someth/text.t" -H "FILE_NAME: text.t" -v

curl localhost:6565/decrypt/upload/ -X POST -d "title=comewords&content=articleContent" -v

underscores_in_headers on;

location /xxfcgi{
			fastcgi_pass        192.168.99.193:6565;
			fastcgi_param REQUEST_METHOD $request_method;
			client_max_body_size 100m;
		}

静态链接需要注意顺序，A程序依赖B库，B库依赖C库 那么A的makefile文件里链接顺序是 -lB -lC 是一种回溯的关系

GLOB_RECURSE会把build目录里的cpp和h拉进来，需要去掉

file(GLOB_RECURSE PROJECT_SOURCES ${CMAKE_SOURCE_DIR}/*.cpp ${CMAKE_SOURCE_DIR}/*.h)
file(GLOB_RECURSE BUILD_CODE "build/*.cpp" "build/*.h")
list(REMOVE_ITEM PROJECT_SOURCES ${BUILD_CODE})

./fcgi_de264 -p 6565 -d /decrypt264/

-s /decrypt264/14-10-00(002ea52b).264 -u 158897 -d 1007710900

./decrypt -s /decrypt264/14-10-00\(002ea52b\).264 -u 158897 -d 1007710900

"158897", "1007710900"

<p>
            <a href="/download/t.txt" download="文件名.txt">点击下载</a>
        </p>

查看可执行程序依赖的库： objdump -x 可执行程序名| grep NEEDED.

库的链接时路径和运行时路径

    现代连接器在处理动态库时将链接时路径（Link-time path）和运行时路径（Run-time path）分开,用户可以通过-L指定连接时库的路径，通过-R（或-rpath）指定程序运行时库的路径，大大提高了库应用的灵活性。

-Wl,-rpath=./ 
-Wl表示链接时将当前目录传递
-rpath表示运行时搜索当前目录

程序部署不能直接将二进制文件拷贝到目标机器或服务器上，需要先找到目标机器的工具链交叉编译打包，才能部署

利用__attribute__((section()))构建初始化函数表

ZRT_WIFI_MODE

make
cp zrt_app $nfss -v


{
    "configurations": [
        {
            "name": "(gdb) 启动",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/fcgi_de264",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "为 gdb 启用整齐打印",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "将反汇编风格设置为 Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ]
        }
    ],
    "version": "2.0.0"
}

ffmpeg -i "C:\testdata\14-10-00(002ea52b)-decrypted0.mp4" -vcodec copy -an -bsf:v h264_mp4toannexb  "C:\testdata\raw.h264"

其中：

-i是输入文件名

-vcodec copy是指直接解复用，不解码，copy到目的文件

-an audio none，禁用音频文件

-bsf:v h264_mp4toannexb mp4有两种startCode模式，这里用annexb模式。

fw_printenv mac


pip3 install torch torchvision torchaudio
2.0.1+cpu

cp -r /home/mars/nfs_share/upload_pic /mnt/hgfs/share/

#define UPLOAD_PIC_PATH "/config/upload_pic/"
static int count=0;
void file_write(char* filepath,char* buf,int len){
	FILE* fp = fopen(filepath, "wb");
	if(!fp) return;
    fwrite(buf, len, 1, fp);
	fclose(fp);
	ZRT_LOG_INFO("write file %s\n",filepath);
	count++;
}


char* file_read(char* filepath,int *size)
{
	FILE *fp = fopen(filepath, "rb");
	if (!fp)
		return 0;
	fseek(fp, 0, SEEK_END);
	*size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	char *tmp = (char *)malloc(*size * sizeof(char));
	fread(tmp, *size, 1, fp);
	ZRT_LOG_INFO("read file %s, size: %d\n",filepath, *size);
	return tmp;
}



	int file_len = 0;
	char *pic1 = file_read("/config/fire/fire1.jpg", &file_len);
	Picture_Server_Upload(obj, pic1, file_len);
	free(pic1);

	sleep(1);
	char *pic2 = file_read("/config/fire/fire2.jpg", &file_len);
	Picture_Server_Upload(obj, pic2, file_len);
	free(pic2);
	
	return 0;

if (res_body && (res_body->reco_info.lKindNo & (1 << FIRE)))
			{
				ZRT_LOG_INFO("detect fire, alarm\n");
			}
			ZRT_LOG_INFO("AI_RECOGNITION: %d\n",res_body->reco_info.lKindNo);


40:6A:8E:FF:29:01

fw_printenv mac

406A8EFF2901

VALGRIND_LIB=/media/usr/lib/valgrind ./usr/bin/valgrind zrt_app


 shared libraries: libstdc++.so.6: cannot open shared object file

 apt-get install lib32stdc++6

 为/root目录创建软连接
[root@localhost ~]# ln -s /root /etc/root1



export LD_LIBRARY_PATH=/media/usr/lib:$LD_LIBRARY_PATH
./usr/bin/gdb  zrt_app_debug

gdb调试 coredump 
gdb program coredump
例如 /media/usr/bin/gdb /media/zrt_app /media/coredump_974_ZRT_MediaDataTh
usr/bin/gdb -e x_app -c coredump_872_x_app -s x.dbg
调试包含调试信息的程序，不要加-e参数，会导致读不到符号信息
可以使用以下命令在GDB中传递参数
run arg1 arg2 ...

wpa_supplicant -Dnl80211 -iwlan0 -c/media/wpa_supplicant.conf -B
./wpad wpa_supplicant -Dnl80211 -iwlan0 -c/media/wpa_supplicant.conf -B


wpa_cli -i wlan0 scan              #扫描附近热点
wpa_cli -i wlan0 scan_result       #打印热点信息

wpa_cli -i wlan0 add_network       # 添加一个网络连接,并返回网络ID号,如果wpa_supplicant.conf文件为空,则返回0,表示第一个热点,然后该ID号会在连接热点用到
wpa_cli -i wlan0 set_network 0 ssid '"Redmi_87C0_2G"'    #设置ID为0的热点SSID
wpa_cli -i wlan0 set_network 0 psk '"88888888"'    #设置ID为0的热点的密码

如果是没有加密的公共网络,则输入以下密码:
wpa_cli -i wlan0 set_network 0 key_mgmt NONE

wpa_cli -i wlan0 get_capability key_mgmt

wpa_cli -i wlan0 set_network 0 priority 2     //设置当前网络优先级,默认为2
wpa_cli -i wlan0 set_network 0 scan_ssid 1    //设置ssid默认为1即可
wpa_cli -i wlan0 enable_network 0            //启动连接ID为0的网络

wpa_cli -i wlan0 select_network 0             //选择网络0(这样做的好处在于,可以取消先前的其它网络连接)

udhcpc -b -i wlan0 -q    
         //此时只是连接上,所以还要自动分配IP地址,-b:后台(back) –i:指定接口 –q:获得续约后退出

wpa_cli -i wlan0 set_network 0 ieee80211w 2
wpa_cli -i wlan0 set_network 0 key_mgmt SAE


wpa_cli -i wlan0 save_config    //保存当前连接的网络配置到wpa_supplicant.conf文件中,使得下次自动连接

从文件中获取wlan0的网卡地址
cat /sys/class/net/wlan0/address


完整的联网流程
wpa_supplicant -B -Dnl80211 -iwlan0 -c/etc/wpa_supplicant.conf

wpa_cli -i wlan0 add_network
wpa_cli -i wlan0 set_network 0 ssid '"newifi_b889"'
wpa_cli -i wlan0 set_network 0 psk '"puwell007"'
wpa_cli -i wlan0 select_network 0 
wpa_cli -i wlan0 enable_network 0 
udhcpc -iwlan0


占用ip的方法 先用udhcpc动态获取ip，再用ifconfig设置ip
udhcpc
#设置ip为192.168.99.120
ifconfig eth0 192.168.99.120 netmask 255.255.255.0 

/etc/init.d/run.sh


root@(none):~# wpa_cli -i wlan0 enable_network 0   
OK
root@(none):~# [10751.912927] RTW: wlan0- hw port(0) mac_addr =c4:3c:b0:74:bc:d3
[10751.920170] RTW: wlan1- hw port(1) mac_addr =c6:3c:b0:74:bc:d3
[10751.938753] RTW: nolinked power save leave
wlan0: Trying to associate with [10753.807064] RTW: rtw_set_802_11_connect(wlan0)  fw_state=0x00000000
a4:39:b3:76:b8:41 (SSID='Redmi_87C0' freq=2442 MHz)
[10753.941748] RTW: start auth
[10753.957093] RTW: auth success, start assoc
[10754.015454] RTW: assoc success
wlan0: Associated with a4:39:b3:76:b8:41
wlan0: CTRL-EVENT-SUBNET-STATUS-UPDATE status=0
[10754.027674] RTW: ============ STA [a4:39:b3:76:b8:41]  ===================
[10754.036168] RTW: mac_id : 0
[10754.039288] RTW: wireless_mode : 0x0b
[10754.043418] RTW: mimo_type : 0
[10754.046993] RTW: bw_mode : 20MHz, ra_bw_mode : 20MHz
[10754.052584] RTW: rate_id : 3
[10754.055818] RTW: rssi : 56 (%), rssi_level : 0
[10754.060798] RTW: is_support_sgi : Y, is_vht_enable : N
[10754.066549] RTW: disable_ra : N, disable_pt : N
[10754.071621] RTW: is_noisy : N
[10754.074942] RTW: txrx_state : 0
[10754.078540] RTW: curr_tx_rate : CCK_1M (L)
[10754.083146] RTW: curr_tx_bw : 20MHz
[10754.087053] RTW: curr_retry_ratio : 0
[10754.091153] RTW: ra_mask : 0x00000000000fffff
[10754.091153] 
[10754.148732] RTW: recv eapol packet
[10754.153059] RTW: send eapol packet
[10754.170472] RTW: recv eapol packet
[10754.174607] RTW: send eapol packet
[10754.178822] RTW: set pairwise key camid:0, addr:a4:39:b3:76:b8:41, kid:0, type:AES
wlan0: WPA: Key negotiation comp[10754.188011] IPv6: ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
leted with a4:39:b3:76:b8:41 [PTK=CCMP GTK=CCMP]
wlan0: CTRL-EV[10754.201193] RTW: set group key camid:1, addr:a4:39:b3:76:b8:41, kid:1, type:AES
ENT-CONNECTED - Connection to a4:39:b3:76:b8:41 completed [id=0 id_str=]


apt-get install  libncurses5-dev gawk

multiple definition of `yylloc` gcc版本过高

find . -name "wpad"|xargs -i ls -l {}

find . -name "test*"|xargs -i cp {} /media

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media/iperf3

vscode  Ctrl+D 选词


ssh win免密登录linux设置
1 生成密钥对 将在C:\User\name\.ssh 目录下生成
2 将公钥内容拷贝到linux服务器的 ~/.ssh/authorized_keys文件中
3 用ssh root@192.168.x.x -i C:\User\name\.ssh\id_rsa 测试登录

IdentityFile "C:\Users\admin\.ssh\id_rsa"

/v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY

vscode 的缓存文件 都存在这里 C:\Users\admin\AppData\Roaming\Code

C:\Users\admin\AppData\Roaming\Code\User\workspaceStorage

生成一个10m的文件
dd if=/dev/zero of=./file.txt bs=1M count=10 

 ./iperf3 -c 192.168.99.224 -u -b 100M -f M
 ./iperf3 -c 192.168.99.224 

 SDK_DIR=/extern/v853
PROJECT_DIR=/home/mars/workspace/code/qzsdk

/media/iperf3/iperf_run.sh &

恢复sdk默认配置
target\allwinner\v851se-perf1/defconfig 

打包出错了先用make看一下具体哪里报错，因为打包用的是make -j32多线程编译
一般的，可以先清理mpp 然后再mkmpp
cleanmpp
mkmpp
成功后再make -j32一般没问题
mboot 编译boot0和uboot
mkernel 编译内核
mkmpp 编译mpp库
svn 清理掉多余文件直接make -j32编译，不需要make menuconfig关闭sample选项

source ./build/envsetup.sh
        lunch 5


svn revert --recursive .
#svn 还原当前文件夹，可以在子文件夹使用，将只作用与子文件夹
svn revert -R . 

svn st | grep '^?' | awk '{print $2}' | xargs rm -rf 清理（删除）未跟踪文件

svn info 查看当前版本
svn status 查看更改的文件
svn diff -r 28:25 [something]
svn update -r [版本号] 回滚到指定版本

要查看远程版本库的日志并限制为5个记录，可以使用以下命令：

svn log -l 5 <远程目录URL>

svn update -r 283

echo '1:2:3' |tr -d : #用tr命令删除输出的字符串中:  
cat test.txt |tr -d : #用tr命令删除输出的字符串中:  
echo '1:2:3' |tr ':' ',' #用tr命令替换输出的字符串中:  

C:sshkey/key tt

解决这种问题需要进行设置,不让他自动转义,执行命令(命令的意思是开启目录扩展,-s是打开):
shopt -s direxpand

在~/.bashrc文件后加入shopt -s direxpand一行
然后 source ~/.bashrc可全局生效

export LD_LIBRARY_PATH=/media/usr/lib:$LD_LIBRARY_PATH
./usr/bin/gdb  zrt_app_debug
/media/usr/bin/gdb -e zrt_app -s zrt_app.debug -c coredump_


md5sum 

VERSION=7.02.93test


BUILD_SDK=y
BUILD_MPP=n
BUILD_PACKUPDATE=n
BUILD_LIBS=n
BUILD_DAEMON=n
BUILD_APP=y
BUILD_FUSE=n
BUILD_PRODUCTION=n
BUILD_TESTBOARD=n


SDK_DIR=/extern/v853
PROJECT_DIR=/home/mars/workspace/code/package

pack/8M/rootfs/build_rootfs.sh
#rm ./etc/init.d/S50netadb

简化find命令
alias findx='/command/find.sh'
find.sh脚本
#set -x
#path=$(readlink -f $1)
#echo $path
if [ $# != 2 ];then
       exit
fi
if [ -z $1 ] || [ -z "$2" ]; then
        echo param is null p1=$1 p2=$2
else
        find $1 -name "$2"
fi

makefile make不是执行all目标而是执行第一个目标，所以一般把all目标放在第一个位置

"workbench.colorCustomizations": {
        //"editor.selectionHighlightBorder": "#00ff15", // 高亮
        "editor.selectionBackground": "#f003ffa6",
        //"editor.selectionForeground": "#404245",
        //"editor.selectionHighlightBackground": "#098709",

        "editor.wordHighlightBackground": "#1c5e84a5",
        "editor.wordHighlightBorder": "#00ff0d",
        //"editor.wordHighlightStrongBackground": "#ff0000",
        //"editor.wordHighlightStrongBorder": "#ff0000",
        //"editor.wordHighlightTextBackground": "#ff0000",
        //"editor.wordHighlightTextBorder": "#ff0000",
        
        "editor.findMatchBackground": "#f003ffa6",//搜索匹配的背景色
        "editor.findMatchHighlightBackground": "#f003ffa6",
        //"editor.findRangeHighlightBackground": "#ff9900",
        "editorOverviewRuler.findMatchForeground": "#17ff02",//右侧滚动条高亮
        "scrollbarSlider.background": "#bba76d",
        "scrollbarSlider.hoverBackground": "#cfb56a",
        "scrollbarSlider.activeBackground": "#fbdd86"
        },



if(1 == judge_UnitCamera_device()){
		ZRT_LOG_INFO("SetAwbStatsSyncMode:ISP0_ISP1_COMBINE\n");
		AW_MPI_ISP_SetAwbStatsSyncMode(1, ISP0_ISP1_COMBINE); 
	}


h264 的i帧前面需要有spspps信息，比如我从一个相机里能得到IPPPPPPIPPPPIPPPPPP这样的原始帧数据，我要将它写入到.h264文件中并能够播放，我需要在每个I帧前插入spspps信息


if(iProfileIdx < 2 && (ZRT_ABS_hasMotor() || ZRT_ABS_isZoomCamera()))

DESCRIBE rtsp

/media/DownloadTest http://ush.ipc365.com:8080/httpdownload/download/PUWELL_PA2_Q851SE+8188_16M_V7.02.76_20230707.bin /media/xx.bin

查看目录dir下1层文件或目录所占的空间
du -h --max-depth=1 /root |sort -rh
磁盘占用太大一般是/root/.vscode-server的问题，将它删掉即可,但会丢失插件

查看固件版本
cat /etc/version.conf

perror.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
    if (argc <= 1)
    {
        return 0;
    }
    int no = atoi(argv[1]);
    printf("errno %d: %s\n", no, strerror(no));

    return 0;
}

把程序拷贝到 /usr/local/bin/ 目录 可以被命令行调用

#define xprint(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)

-D_USE_MP4 -Dxprint\(fmt\,...\)=printf\(\"\%s:\"\"\#\#mp4\#\#\ \"fmt\"\\n\"\,__func__\,\#\#__VA_ARGS__\)


ifconfig eth0 down
ifconfig eth0 hw ether 0a:1b:b4:00:89:0e
ifconfig eth0 up

/usr/sbin/wpa_cli

目前全志系列的固件版本为：p1--变焦枪球，p3--三目拼接，p7--小蛋，7.02.XX--常规/拼接枪球，7.20.XX.T1--低功耗

wifi信息存在 /config/cfg.txt

/media/usr/bin/gdb  -e zrt_app -s zrt_app.debug -c coredump_1031_CLD_InitThread

gcc 高亮错误
-g -fdiagnostics-color=always

全志 v853芯片
格科微 gc2083 sensor
Camera Compact Module 摄像头模组
南阳禾立光电

只想看已经被修改的文件，你可以使用grep命令过滤输出，像这样：
svn status | grep '^M'
svn status | grep '\.c$'


Tina_Linux_系统软件_开发指南.pdf



如果解密不出来可以用这个解密试试 C:\重要文档\pwdecrypt-fix

httpclient_response_parse
ZRT_LOG_INFO("%-128s\n",data);


SDK_DIR=/extern/Puwell-V853
PROJECT_DIR=/home/mars/workspace/code/qzsdk

repo清除所有修改及更新命令
repo forall -c "pwd;git clean -f;git checkout -f";repo sync -c --no-tags;repo sync -l;


patch -p1 < xx.patch 表示将xx补丁打入当前目录，并去掉前第一个路径
patch -p1 -R < xx.patch 卸载补丁
patch -p0       (“p”指的是路径，后面的数字表示去掉路径的第几部分。"0"，表示不去掉，为全路径)
patch -p1       (“p”后面的数字"1"，表示去掉前第一个路径)


15988184546 
puwell119

^(?=.*a)(?=.*b).*$  包含a且包含b的一行

	cdx_sem_t sem_gdc;
	sGdcParam gdc_param;
	int zoomH;
	int zoomV;

    // pthread_mutex_lock(&pContext->m_switchMutex);
	// if (pContext->gdc_param.bGDC_en)
	// {
	// 	cdx_sem_wait(&pContext->sem_gdc);
	// 	// ZRT_LOG_INFO("sem back\n");
	// }
	// if (2 == pContext->m_switchStatus)
	// {
	// 	if (pContext->gdc_param.bGDC_en && 
	// 	(pContext->gdc_param.zoomH == pContext->zoomH) && 
	// 	(pContext->gdc_param.zoomV == pContext->zoomV))
	// 	{
	// 		// pContext->m_switchStatus = 0;
	// 		// AW_MPI_VENC_RequestIDR(0, TRUE);
	// 	}
	// 	else
	// 	{
	// 		ZRT_LOG_INFO("drop frame\n");
	// 		// bDrop = true;
	// 		// AW_MPI_VENC_RequestIDR(0, TRUE);
	// 	}
	// }
	// pthread_mutex_unlock(&pContext->m_switchMutex); 

    // case MPP_EVENT_VENC_GDC_PREOCESS_COMPLETE:
            // {
            //     sGdcParam *gdc_param = (sGdcParam *)pEventData;
			// 	context_t *pContext = (context_t *)cookie;

            //     memcpy(&pContext->gdc_param, gdc_param, sizeof(sGdcParam));
            //     // ZRT_LOG_INFO("call back\n");
            //     cdx_sem_up(&pContext->sem_gdc);
            // }
    int ZRT_Switch_Enc(context_t *pContext, int target_sensor, GSRECT stNextRoi)


/mnt/UDISK/language/video_close.g711a
/mnt/UDISK/language/dingdong.g711a
/mnt/UDISK/language/ap_mode.g711a
/mnt/UDISK/language/alarm.g711a
/mnt/UDISK/language/smoke.g711a
/mnt/UDISK/language/call.g711a
/mnt/UDISK/language/motion.g711a
/mnt/UDISK/language/net_connect.g711a
/mnt/UDISK/language/upgrade_start.g711a
/mnt/UDISK/language/dhcp_getip_failed.g711a
/mnt/UDISK/language/upgrade_success.g711a
/mnt/UDISK/language/video_open.g711a
/mnt/UDISK/language/upgrade_fail.g711a
/mnt/UDISK/language/input_ssid.g711a
/mnt/UDISK/language/passwd_err.g711a
/usr/bin/VoiceCN/dhcp_getip_failed.g711a
/usr/bin/VoiceCN/net_connect.g711a
/usr/bin/VoiceCN/passwd_err.g711a
/usr/bin/VoiceCN/upgrade_fail.g711a
/usr/bin/VoiceCN/upgrade_start.g711a
/usr/bin/VoiceCN/upgrade_success.g711a
/usr/bin/VoiceCN/video_close.g711a
/usr/bin/VoiceCN/video_open.g711a
/usr/bin/VoiceEN/dhcp_getip_failed.g711a
/usr/bin/VoiceEN/net_connect.g711a
/usr/bin/VoiceEN/passwd_err.g711a
/usr/bin/VoiceEN/upgrade_fail.g711a
/usr/bin/VoiceEN/upgrade_start.g711a
/usr/bin/VoiceEN/upgrade_success.g711a
/usr/bin/VoiceEN/video_close.g711a
/usr/bin/VoiceEN/video_open.g711a
/usr/bin/VoiceGeneral/ap_mode.g711a
/usr/bin/VoiceGeneral/call.g711a
/usr/bin/VoiceGeneral/dingdong.g711a
/usr/bin/VoiceGeneral/input_ssid.g711a
/usr/bin/VoiceGeneral/motion.g711a
/usr/bin/VoiceGeneral/smoke.g711a

/media/tcp_client 16663 1 /usr/bin/VoiceGeneral/ap_mode.g711a
/media/tcp_client 16663 1 /usr/bin/VoiceCN/net_connect.g711a
/media/tcp_client 16663 1 /usr/bin/VoiceCN/dhcp_getip_failed.g711a

159881
1009873167
日志搜索device_id camera_id 获取设备id


for(i = 0; i < g_stAllFocus.lNum; i++)
        {
            ZRT_LOG_DBG("Area = %d, mask x,y = [%f, %f], region = [%d,%d,%d,%d]\n", 
        g_stAllFocus.pstTarList[i].lArea,
        g_stAllFocus.pstTarList[i].stCentroidF.x, g_stAllFocus.pstTarList[i].stCentroidF.y,
        g_stAllFocus.pstTarList[i].stRegion.left, g_stAllFocus.pstTarList[i].stRegion.top, g_stAllFocus.pstTarList[i].stRegion.right, g_stAllFocus.pstTarList[i].stRegion.bottom);
        }

        ZRT_Motion_OsdUpdate_v2(1, 0, GUN_OSD, (void*)&g_stAllFocus);


certutil -hashfile "C:\path\to\your\file" MD5

/config/unitcam.cfg

/extern/v853/lichee/linux-4.9/drivers/media/platform/sunxi-vin/modules/sensor


int ShakeCtrl::__Ptz_set_target_degree(int pan_degree, int is_pan_speed_gear, int tilt_degree, int is_tilt_speed_gear)
{
    int ret = 0;
    if(Ptz_motor_is_stop(PTZ_PAN) == 0 || Ptz_motor_is_stop(PTZ_TILT) == 0)
    {
        //对可能存在的异常做处理。如果剩余很多负数的(或者圈数寄存器是0)，则可能是芯片寄存器
		//没更新到，先暂时不处理，等待下次恢复正常在处理
        if((ret = Ptz_onestep_stop(NULL)) < 0)
        {
            printf("[%s:%d]: ptz motor is not update\n", __FUNCTION__, __LINE__);
            return -1;
        }
    }
    
    Ptz_motor_set_speed(21);
    // Ptz_motor_set_speed(m_ShakeCtrlInfo.MotorConfig.lStepFreq);


echo 96  > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio96/direction
echo 1 > /sys/class/gpio/gpio96/value

cat /sys/kernel/debug/mpp/isp
cat /sys/kernel/debug/mpp/ve_*

ffmpeg -f alaw -ar 8000 -ac 1 -i upgrade_start.pcma -vcodec copy test.mp4

检查有没有进产测 搜wlan0 如果有很多信息打印就是进了 还可以搜factory如果很多factory函数打印就是进了

ffplay -f alaw -ac 1 -ar 8000 -i avps.ps

	.AEncattr.AeAttr.sampleRate = 8000,
	.AEncattr.AeAttr.channels = 1,	
	.AEncattr.AeAttr.bitRate = 0,
	.AEncattr.AeAttr.bitsPerSample = 16,
	.AEncattr.AeAttr.attachAACHeader = 1,
	.AEncattr.AeAttr.Type = PT_G711A,



ffmpeg -f alaw -ar 8000 -ac 1 -i rec.g711a -acodec copy output.mpg

ffmpeg -i mpeg2-pcm-misdetect.mpg -vn -c copy -f vob detach.mpg

/extern/v853/external/eyesee-mpp/middleware/sun8iw21/media/videoIn/videoInputHw.c

/extern/v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY/libisp

/extern/v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY/libisp/isp.c

驱动目录
/extern/v853/lichee/linux-4.9/drivers/media/platform/sunxi-vin/modules/sensor/  

0x00,0xac,0x2d,0x87,0x54,0x05,0xff,0x01,0xc7,0x00,0x5a,0x50,0x00,0x00,0xb4,0x8c,0x28,0x0f,0x01,0x01

二进制查看文件 查看前300个字节
hexdump -C 21-20-00\(00373202\)_2.mp4 


确认是否能将g711封装成MP4
寻找封装264+g711的库
将原本的加密过程去掉
修改原始接口，传入pts
不止要封装264数据还要将sei sps pps封装进去
修改接口，适应设备的块内存方式
封装时需要修改nalu头为nalu的数据长度


video_common.c ZRT_Set_IspConfigBin 看效果文件配置

ffmpeg打印 Stream # dump_stream_format 分辨率 avcodec_string

要加快程序的写入速度，可以考虑以下几点：

使用缓冲区：将要写入的数据先存储在内存中的缓冲区中，然后一次性批量写入磁盘，而不是逐个数据写入。这样可以减少磁盘 I/O 操作，提高写入速度。

使用异步写入：在需要写入大量数据时，可以考虑使用异步写入方式，即在数据写入的同时，程序可以继续执行其他操作，不必等待写入完成。这样可以提高程序的整体效率。

优化文件格式：选择更适合写入速度的文件格式，比如使用二进制文件格式而不是文本文件格式，可以减少数据转换和处理的时间。

使用更快的存储设备：如果可能的话，将数据存储在更快速的存储设备上，比如固态硬盘（SSD）而不是传统的机械硬盘，可以显著提高写入速度。

考虑使用内存映射文件：对于需要频繁读写的大型文件，可以考虑使用内存映射文件，这样可以直接在内存中对文件进行操作，避免了频繁的磁盘 I/O 操作。


fopen有r、w、a等打开模式，t、b两个文件模式(文本或二进制)

用w、wb、w+b打开，无论如何都会清空原来文件中的数据，很麻烦，如果要多次读取修改文件，清空不是很理想的解决方案，
a、ab、a+b不会破坏原来数据，但只能添加到原来文件数据的后面，fseek基本失效，这样就修改不了原来的数据了，
r虽然不会破坏，但是修改不了，这个时候如果用r+b、r+就可以在保留文件原来内容的情况下设置文件指针后修改指定位置的内容了


\assets\usr\bin\isp\f37p

assets/usr/bin/isp

删除当前目录小于1 byte的文件
find . -type f -size -1c -maxdepth 1 -exec rm {} \;


将一个数以网络字节序放在内存
static uint8_t *make_len(uint8_t *pbuf, int val)
{
    pbuf[0] = (uint8_t)((val >> 24) & 0xFF);
    pbuf[1] = (uint8_t)((val >> 16) & 0xFF);
    pbuf[2] = (uint8_t)((val >> 8) & 0xFF);
    pbuf[3] = (uint8_t)((val >> 0) & 0xFF);
    return pbuf;
}
将网络字节序数读出来
uint32_t bytesToUInt32(char *byte, int len) {
    if (len != 4)
    {
        return 0;
    }
    
    return (byte[0] << 24) | (byte[1] << 16) | (byte[2] << 8) | byte[3];
}

uint32 x=0x12345678;
fwrite((char*)&x,4,1,fp);//将一个数以主机字节序写入文件
fwrite((char*)make_len(&x,4),4,1,fp);//将一个数以网络字节序写入文件

网络字节序就是一个值在代码里看起来是0x12345678 那么写入文件也是12345678，而主机字节序写入后则是78563412

source ./build/envsetup.sh
lunch
2+2 lunch v853s_perf1-tina 7
make menuconfig

尝试封装264+g711 ps
尝试封装264+g711 MP4
去除加密
为了时间戳统一重新打包音频
写入MP4时修改头00000001为nalu长度
通过sps计算分辨率
根据底层编码给的时间戳计算并重打时间戳
修改MP4库，将moov头提到前面
定时更新moov头减小断电重启造成的数据损失
使用缓存，减小io次数，优化磁盘io
修改创建200kb空文件的创建时机
修改MP4库，实现断电续写
修改seek机制
修改回放录像逻辑
修改分辨率更新

#include <iostream>
using namespace std;

#define MOV_TAG(a, b, c, d) (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))
#define MOV_VIDEO	MOV_TAG('v', 'i', 'd', 'e') // ISO/IEC 14496-12:2015(E) 12.1 Video media (p169)
#define MOV_AUDIO	MOV_TAG('s', 'o', 'u', 'n')

int main()
{
	unsigned int a = MOV_AUDIO;
	unsigned int v = MOV_VIDEO;
	
	cout<<a<<" "<<v<<endl;
   return 0;
}


nginx-1.17.9使用增加了stream 模块用于一般的TCP 代理和负载均衡，ngx_stream_core_module 这个模块在1.90版本后将被启用。但是并不会默认安装，
    需要在编译时通过指定 --with-stream 参数来激活这个模块。
      
    1）配置Nginx编译文件参数

./configure --with-stream

    2）编译、安装，make && make install

make & make install
 
    3）配置nginx.conf文件

    stream {
     upstream kevin {
     server 192.168.10.10:8080; #这里配置成要访问的地址
     server 192.168.10.20:8081;
     server 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
     }
     server {
     listen 8081; #需要监听的端口
     proxy_timeout 20s;
     proxy_pass kevin;
     }
    }

      
    创建最高级别的stream（与http同一级别），定义一个upstream组 名称为kevin，由多个服务组成达到负载均衡 定义一个服务用来监听TCP连接（如：8081端口），
    并且把他们代理到一个upstream组的kevin中，配置负载均衡的方法和参数为每个server；配置些如：连接数、权重等等。
      
    首先创建一个server组，用来作为TCP负载均衡组。定义一个upstream块在stream上下文中，在这个块里面添加由server命令定义的server，指定他的IP地址和
    主机名（能够被解析成多地址的主机名)和端口号。下面的例子是建立一个被称之为kevin组，两个监听1395端口的server ，一个监听8080端口的server。
      
    upstream kevin {
     server 192.168.10.10:8080; #这里配置成要访问的地址
     server 192.168.10.20:8081;
     server 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
     }
      
      
    需要特别注意的是：
    你不能为每个server定义协议，因为这个stream命令建立TCP作为整个 server的协议了。
      
    配置反向代理使Nginx能够把TCP请求从一个客户端转发到负载均衡组中(如：kevin组)。在每个server配置块中 通过每个虚拟server的server的配置信息和在
    每个server中定义的监听端口（客户端需求的代理端口号，如我推流的的是kevin协议，则端口号为：8081）的配置信息和proxy_passs 命令把TCP通信发送到
    upstream的哪个server中去。下面我们将TCP通信发送到kevin 组中去。
      
     server {
     listen 8081; #需要监听的端口
     proxy_timeout 20s;
     proxy_pass kevin;
     }
      
    当然我们也可以采用单一的代理方式：
      
    server {
     listen 8081; #需要监听的端口
     proxy_timeout 20s;
     proxy_pass 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
    }
    ------------------------------------------------------------------
      
    4）改变负载均衡的方法：
    默认nginx是通过轮询算法来进行负载均衡的通信的。引导这个请求循环的到配置在upstream组中server端口上去。 因为他是默认的方法，这里没有轮询命令，
    只是简单的创建一个upstream配置组在这儿stream山下文中，而且在其中添加server。


    a）least-connected ：对于每个请求，nginx plus选择当前连接数最少的server来处理:

    upstream kevin {
     least_conn;
     server 192.168.10.10:8080; #这里配置成要访问的地址
     server 192.168.10.20:8081;
     server 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
    }
    

    b）ip_hash ：客户机的IP地址用作散列键，用于确定应该为客户机的请求选择服务器组中的哪个服务器

    upstream myapp1 {
        ip_hash;
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }
    注：这个least time均衡方法没有
    c）普通的hash算法：nginx plus选择这个server是通过user_defined 关键字，就是IP地址：$remote_addr;

    upstream kevin {
     hash $remote_addr consistent;
     server 192.168.10.10:8080 weight=5; #这里配置成要访问的地址
     server 192.168.10.20:8081 max_fails=2 fail_timeout=30s;
     server 192.168.10.30:8081 max_conns=3; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
    }


两张图片，两张图里都是同一个字，但是两张图的尺寸不同，在计算机科学中如何验证两张图里的字是同一个?

在计算机科学中，验证两张图像中的字是否相同通常涉及以下步骤：

图像预处理：首先，需要对两张图像进行预处理，确保它们具有相同的尺寸、颜色空间和对比度。这可以通过调整大小、灰度化和标准化颜色等方法来实现。

特征提取：接下来，从每个图像中提取特征，以便进行比较。一种常见的方法是使用特征描述符（如SIFT、SURF或ORB）来识别图像中的关键点和描述符。这些描述符可以捕获图像的局部特征。

特征匹配：通过比较两幅图像中提取的特征，可以进行特征匹配。这可以通过使用诸如最近邻居（Nearest Neighbors）匹配或一致性检查等算法来实现。

相似度度量：一旦完成特征匹配，可以计算两幅图像之间的相似度分数。这可以通过计算匹配特征点之间的距离或使用一些相似性度量（如结构相似性指数）来实现。

阈值设定：最后，可以根据相似度分数设置一个阈值，以确定两幅图像中的字是否相同。如果相似度分数超过阈值，则可以确定这两个字是相同的。

这些步骤构成了一种基本的图像相似度比较流程，可以用来验证两张图像中的字是否相同。然而，需要注意的是，这些方法可能受到图像尺寸差异、旋转、扭曲等因素的影响，因此在实际应用中需要考虑这些因素。


device/config/chips/v853s/configs/perf1/linux/env-4.9.cfg SWITCH=2
root@mars-virtual-machine:/extern/v853/device/config/chips/v853s/configs/perf1/linux# svn st
M       env-4.9.cfg
M       env-8188.cfg
M       env-EC800E.cfg


        self.conv1 = torch.nn.Sequential(
            torch.nn.Conv2d(1, 10, kernel_size=5),
            torch.nn.ReLU(),
            torch.nn.MaxPool2d(kernel_size=2),
        )
        self.conv2 = torch.nn.Sequential(
            torch.nn.Conv2d(10, 20, kernel_size=5),
            torch.nn.ReLU(),
            torch.nn.MaxPool2d(kernel_size=2),
        )
        self.fc = torch.nn.Sequential(
            torch.nn.Linear(320, 50),
            torch.nn.Linear(50, 10),
        )

linear:
Linear(in_features=4, out_features=3, bias=True)
weight:
Parameter containing:
tensor([[ 0.1580,  0.1197,  0.0419, -0.1967],
        [ 0.3840, -0.4597,  0.2347, -0.3428],
        [-0.3149,  0.2016,  0.2841,  0.4568]], requires_grad=True)

除了使用反向传播算法来找到过滤矩阵（如在卷积神经网络中的过滤器或权重）的方法外，还有其他几种可以探索的方法。以下是一些备选方法：

进化算法：这类算法通过模拟自然选择的过程来优化问题的解。在神经网络中，可以用进化算法来优化网络结构和权重，包括过滤矩阵。这种方法不需要反向传播，而是通过随机变异和选择最佳表现的个体来进化出最优解。

遗传算法：作为进化算法的一种，遗传算法使用交叉和变异操作来生成新的候选解，并用一个适应性函数来评价每个解的质量。这可以用于直接优化网络的权重，包括过滤矩阵。

模拟退火：这是一种概率型优化算法，灵感来源于物理中的退火过程。通过逐渐降低系统温度，模拟退火帮助找到全局最优解，减少陷入局部最优的可能。这种方法可以用于优化神经网络的权重。

粒子群优化（PSO）：这种方法通过模拟鸟群或鱼群的社会行为来优化问题。每个粒子代表一个解，通过跟踪个体和群体的最佳解来更新自己的位置和速度。这种方法同样适用于优化网络权重。

梯度自由优化：在某些情况下，可能需要在没有梯度信息的情况下优化权重，尤其是当损失函数不可导时。例如，使用Nelder-Mead单纯形方法等。

贝叶斯优化：这是一种基于概率模型的全局优化策略，常用于优化计算成本高昂的问题。通过建立目标函数的概率模型，贝叶斯优化可以有效地找到最优解。

强化学习：尽管通常用于不同的应用场景，但理论上可以通过设计一种环境和奖励机制，使用强化学习来优化神经网络的权重。
########################################

判断两个数据是否相似，可以使用上述提到的几种方法中的某些方法，尤其是那些用于特征提取和数据降维的方法。以下是几种适用于相似性判断的方法：

主成分分析（PCA）： 通过PCA，可以将两个数据集转换到相同的低维空间中，然后比较它们在这个空间中的距离或相似性。如果两个数据集在PCA变换后的主成分得分（或者说，低维表示）接近，那么可以认为它们在某种程度上是相似的。

自动编码器（Autoencoder）： 自动编码器同样可以用于提取数据的低维特征表示。如果两个数据点通过同一个训练好的自动编码器得到的编码（低维表示）相似，那么这两个数据点也可以被认为是相似的。这种方法在处理非线性数据关系时尤为有效。

奇异值分解（SVD）： 通过SVD也能得到数据的低维表示。通过比较两个数据矩阵的奇异值分解结果，可以估计它们的相似性。相似的数据将在奇异值和对应的奇异向量上表现出相似性。
########################################

概念和概念之间通过一个隐藏层连接，隐藏层需要建立一个索引系统，对于不同的语境，触发不同的隐藏节点

首先先建立语境，语境就是第一直觉，可以是对一系列的输入进行一个md5的过程，有了第一直觉，再通过第一直觉将信息进行分类识别

有一种神经网络模型叫做混合专家模型（Mixture of Experts），它可以根据输入的特征选择不同的隐藏层结构。具体来说，混合专家模型由多个专家网络组成，每个专家网络可以有不同的架构和参数。此外，还有一个称为门控网络（Gating Network）的部分，它根据输入特征来决定每个专家网络的权重，也就是说，它会根据输入的特征来选择最合适的专家网络或组合。

import torch

# 创建一个示例二维张量
tensor = torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])

# 沿维度0计算均值
mean_dim0 = torch.mean(tensor, dim=0)
print("Mean along dimension 0:", mean_dim0)

# 沿维度1计算均值
mean_dim1 = torch.mean(tensor, dim=1)
print("Mean along dimension 1:", mean_dim1)

# 沿维度0计算中位数
median_dim0 = torch.median(tensor, dim=0).values
print("Median along dimension 0:", median_dim0)

# 沿维度1计算中位数
median_dim1 = torch.median(tensor, dim=1).values
print("Median along dimension 1:", median_dim1)

PhoenixCard.exe

环境参数更新需要用量产卡刷才能更新

-Dxprint\(...\)#

重启标志
]:application(V


40:6A:8E:FF:38:0F
6d428d1d72f3c9c0b79b118105616dcc

fw_setenv mac 40:6A:8E:FF:38:0F
fw_setenv mac_sign 6d428d1d72f3c9c0b79b118105616dcc

开机脚本
/home/mars/workspace/code/qzsdk/branch/threelens_switch/pack_threelens_switch/assets/etc/init.d/run_16M.sh

如果你想在 D:\Documents 目录下搜索，你应该这样输入：

"D:\Documents"

如果你想进一步搜索该目录下的特定文件或文件夹，可以在路径后添加搜索关键词。例如，搜索所有的 PDF 文件，可以这样输入：
"D:\Documents" *.pdf

或者，如果你想在该目录下只搜索文件夹，可以结合之前的 folder: 语法：

"D:\Documents" folder:

写驱动寄存器
cd /sys/devices/f37p_mipi #进入f37p_mipi驱动目录
echo 1 > read_flag #1读 0写
echo 00220000 > cci_client #地址0x22
cat read_value #获取值

echo 0 > read_flag #1读 0写
echo 00120030 > cci_client #往地址0x22写入0x30
cat read_value

cd /sys/devices/f37p_dvp;echo 0 > read_flag;echo 000c0001 > cci_client #walking1测试模式

if (!run_flag[i])
		{
			new_degree[i] = curr_degree[i];
		}
		else
		{
			new_degree[i] = curr_degree[i] + diff_curdegree*0.9;//并不直接转向目标点，只往那个方向转一部分，消除震荡
		}


型号 普维方案定义表

svn checkout https://192.168.10.195:448/svn/Qz-IPC/trunk/tina-v853 ./tina-v853

/tina-v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY  编码库目录

v851se_vc2 ## v851se 2+1 
v851s3_vc  ## v851s3 2+1 全时变焦2+1

[2024/5/23 13:36:13] /usr/bin/check_stream.sh
[2024/5/23 13:36:13] =======check video node =========
[2024/5/23 13:36:13] video0   video10  video13  video2   video5   video8
[2024/5/23 13:36:13] video1   video12  video14  video4   video6   video9
[2024/5/23 13:36:13] =======check sensor mipi clk=========
[2024/5/23 13:36:13] mipi0 sensor clk : OK, clk_mode: Continuous Mode
[2024/5/23 13:36:13] cannot connect to the server
[2024/5/23 13:36:13] mipi1 sensor clk : OK, clk_mode: Continuous Mode
[2024/5/23 13:36:13] =======check mipi d0 trnds=========
[2024/5/23 13:36:13] mipi0-d0 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] mipi0-d1 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] mipi1-d0 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] mipi0-d1 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] =======check mipi int erro=========
[2024/5/23 13:36:13] mipi0:
[2024/5/23 13:36:13] not erro
[2024/5/23 13:36:13] mipi1:
[2024/5/23 13:36:13] not erro
[2024/5/23 13:36:13] =======check dvp polarity=========
[2024/5/23 13:36:13] DVP_CLK_POL: active in falling edge
[2024/5/23 13:36:13] DVP_HERF_POL: positive
[2024/5/23 13:36:13] DVP_VREF_POL: negative
[2024/5/23 13:36:13] =======check dvp pclk cnt=========
[2024/5/23 13:36:13] DVP PCLK CNT: OK
[2024/5/23 13:36:13] =======check sensor mipi width & height=========
[2024/5/23 13:36:13] mipi0=> width:1920 , height:1080
[2024/5/23 13:36:13] mipi1=> width:1920 , height:1080
[2024/5/23 13:36:13] dvp=> width:1920 , height:1080
[2024/5/23 13:36:13] =======check csi mclk=========
[2024/5/23 13:36:13] csi0_mclk : NO
[2024/5/23 13:36:13] csi0_mclk_fre: 24000000
[2024/5/23 13:36:13] csi1_mclk : NO
[2024/5/23 13:36:13] csi1_mclk_fre: 24000000
[2024/5/23 13:36:13] csi2_mclk : NO
[2024/5/23 13:36:13] csi2_mclk_fre: 24000000
[2024/5/23 13:36:13] =======show vi pipe line =========
[2024/5/23 13:36:13] f37p_mipi => mipi0 => csi0 => tdm_rx0 => isp0 => vipp0
[2024/5/23 13:36:13] f37p_mipi_2 => mipi1 => csi1 => tdm_rx1 => isp1 => vipp1
[2024/5/23 13:36:13] f37p_dvp => csi2 => tdm_rx2 => isp2 => vipp2
[2024/5/23 13:36:13] =======check vi ch stream =========
[2024/5/23 13:36:15] vi stream is ok
[2024/5/23 13:36:15] =======check sensor i2c sda status=========
[2024/5/23 13:36:15] f37p_mipi i2c-0 SDA_STATUS: High, ok
[2024/5/23 13:36:15] f37p_mipi_2 i2c-1 SDA_STATUS: High, ok
[2024/5/23 13:36:15] f37p_dvp i2c-4 SDA_STATUS: High, ok
[2024/5/23 13:36:15] ==========END============


./i2cdetect -l        //用i2cdetect检测有几组i2c总线在系统上
./i2cdetect -r -y 1    //用i2cdetect检测挂载在i2c1总线上器件 
./i2cdump -f -y 1 0x49      //用i2cdump查看器件所有寄存器的值
用i2cset设置单个寄存器值，用i2cget读取单个寄存器值，可以在初期调试时发挥很大作用，一旦有预期的现象出现，就可以用i2cdump读出整个寄存器的值，然后固化到代码中。
./i2cset -f -y 1 0x20 0x77 0x3f （设置i2c-1上0x20器件的0x77寄存器值为0x3f）
./i2cget -f -y 1 0x20 0x77     （读取i2c-1上0x20器件的0x77寄存器值）

写一个shell脚本，用i2cset 将总线n上的m器件的u组数据写入寄存器，u组数据中包括地址v1 v2 ... vu，值w1 w2 ... wu
用python opencv写一个程序，主线程是一个固定窗口，还有一个子线程，窗口是一个绘制图片的窗口，窗口的生命周期就是程序的生命周期，线程从一个队列里读取数据，数据是一张图片，只要读到数据就重绘窗口内容，即清空窗口然后在窗口中绘制读到的图片

./set.sh 4 0x44 data.txt 
./set.sh 4 0x44 init_data.txt 
./get.sh 4 0x44 data.txt 

t5 ng rewrite reg
t6 ng log
t7 log 
t8 ng  log rewrite reg
t9 =t6
t10 =t8


t12 ng rewrite reg
t13 ng 没有rewrite reg

t15 没有ng 有日志打印 没有rewrite reg
t16 ng 有日志打印 没有rewrite reg

t18 ng + daemon_app 日志
t19 no ng + daemon_app 日志
t20 =t18
t21 =t19

t22 ng + daemon_app 日志 额外写

t23 ng + 记录uboot

t6 nodog + ng+ daemon_app 日志
t7 nodog + no ng+ daemon_app 日志
t9 nodog + ng 4路dma搬运 + daemon_app 日志

M       device/config/chips/v853s/configs/perf2/board.dts
M       device/config/chips/v853s/configs/perf2/linux/config-4.9
M       lichee/linux-4.9/drivers/media/platform/sunxi-vin/modules/sensor/f37p_dvp_gun.c


13606800301
Lixun1973

rm -rf /media/2024* /media/coredum* /media/1970* /media/*.alaw /media/*_*.mp4

mount --bind /media/extsd /mnt/extsd
cp -r /tmp/nfs_share/extsd/ /media/extsd/
/mnt/extsd/demo_rtsp -path /mnt/extsd/venc_0.conf &

/media/op_reg.sh
/media/rw_cfg.sh

killall demo_rtsp


删除size为0的(乱码)文件
find . -type f -size 0 -exec rm -f {} \;

echo -e "\033[0m"

用fuse挂载 
/usr/bin/allwin_fuse /media/ 
卸载
umount /media

mkfs.vfat -F 32 /dev/mmcblk0 #给存储设备mmcblk0制作FAT32文件系统
mount /dev/mmcblk0 /media  #把设备mmcblk0挂载到 /media

umount /media
mount /dev/mmcblk0 /media
mount /dev/mmcblk0 /mnt/extsd

umount /media;mount /dev/mmcblk0 /media;mount /dev/mmcblk0 /mnt/extsd;rm /mnt/extsd/*.raw;cp /media/gbl_rootfs.bint8 /media/gbl_rootfs.bin;/mnt/extsd/start.sh 

setenv SWITCH 2
saveenv 

svn commit -m "Your commit message here"

mac_sign=8357b50e384a6612afb4cb7dae2c6f0b
mac=40:6A:8E:FF:37:F1

fw_setenv mac 40:6A:8E:FF:37:F1
fw_setenv mac_sign 8357b50e384a6612afb4cb7dae2c6f0b