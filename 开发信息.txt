fsck 内存映射
视频解密 nginx
onvif rstp
火警检测 
升级md5校验

要确定一个压缩文件的真正格式，即使文件的后缀名是错误的，你可以使用 file 命令来检查文件的魔数（magic number）。
file 文件名

例如，如果要将名为 myfolder 的文件夹打包成 myfolder.tar.gz 文件，可以使用以下命令：

tar -czvf myfolder.tar.gz myfolder

vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs-fuse,allow_other
tar -zcvf include.tar.gz include/
tar -xzf
tar -xzf /bbs.tar.zip -C /zzz/bbs
unzip pwdecrypt.zip -d ./pwdecrypt/ 
rm -rf !(keep) #删除keep文件之外的所有文件

解压xxxxx.tar.gz 会将里面的yyyyy文件夹解压在当前目录
tar -xzf xxxxx.tar.gz 

zip -r html.zip ./html

假设你有一个 X.tar 文件，你可以使用以下命令将 X.tar 解压到一个名为 X 的文件夹中：
tar -xf X.tar --one-top-level

bash: !: event not found
原因：未开启扩展通配符

shopt使用
shopt [-psu] [optname …]

-s 开启某个选项。
-u 关闭某个选项。
-p 列出所有可设置的选项。

查看扩展通配符是否开启：shopt extglob
开启扩展通配符：shopt -s  extglob

sutt
tt

root
puwell007

touch /config/debug.sh
rm /config/debug.sh

sd卡：
/media
nfs:


/usr/bin 
zrt_app daemon_app

vim 全选 ggVG （区分大小写）
跳转到文件的开始：按 gg 以跳转到文件的第一行。
进入可视行模式：按 V 以进入可视行模式。
跳转到文件的末尾：按 G 以选择从第一行到最后一行的所有内容。

根目录
cd /

find / -name "zrt_app"

find / -name "*_app" | grep "zrt"

root@mars-virtual-machine:/home/mars/.ssh# id
uid=0(root) gid=0(root) groups=0(root)

gedit /etc/exports

/home/mars/nfs_share 192.168.0.0/24(rw,sync,all_squash,anonuid=1000,anongid=1000,no_subtree_check)

/home/mars/nfs_share：要共享的开发主机目录
192.168.0.0/24：配置谁可以访问，其中的/24 是掩码
rw: 表示客户机的权限，rw 表示可读写
sync：资料同步写入到内存与硬盘中。
anonuid=1000：将客户机上的用户映射成指定的本地用户 ID 的用户
anongid=998： 将客户机上的用户映射成属于指定的本地用户组 ID
no_subtree_check：不检查子目录权限，默认配置
————————————————
版权声明：本文为CSDN博主「田三番」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_27961843/article/details/103325967

修改完/etc/exports文件并保存后，可使用exportfs命令更新配置：
#以下命令在主机上运行
sudo exportfs -arv

showmount -e

计算字符串"hello"的md5
echo -n "hello" | md5sum

测试：
mount -t nfs localhost:/home/mars/nfs_share /mnt

chmod -R 777 /mnt

drwxr-x--- 该权限分为4个部分d、rwx、r-x、---。

d:表示文件类型；

rwx：表示文件所有者的对该文件所拥有的权限；

r-x：表示文件所属组对该文件所拥有的权限；

---：表示其他用户对该文件所拥有的权限。

chmod -R 755 该命令表示文件所有者有读写执行权限（4+2+1）、文件所属组有读执行权限（4+1）、其他人有读执行权限（4+1）。

changing permissions of '/usr': Read-only file system
如果是系统文件出现这个问题，重新挂载根目录即可：
mount -rw -o remount /usr

查看 NFS 共享情况
showmount -e

清空屏幕快捷键：
ctrl + l 

清空当前输入快捷键：
ctrl + u

udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share
mount -o vers=4 192.168.0.111:/home/mars/nfs_share /tmp/nfs_share

cp zrt_app /home/mars/nfs_share/zrt_app
cp zrt_app.debug /home/mars/nfs_share/dbg_zrt_app

/tmp/nfs_share/zrt_app &
rm -rf coredump_*

mount -o vers=4 192.168.99.193:/extern/nfs_media /media


com3

115200

udhcpc 设备获取ip

route add 192.168.5.0 mask 255.255.255.0 192.168.2.254 if 24 -p

在这个例子中：

192.168.5.0表示目标网段；

mask后面接掩码，255.255.255.0表示目标网段的掩码；

192.168.2.254表示路由的下一跳地址，也就是，想要到达192.168.5.0的数据，本机都会发给192.168.2.254去转发；

if后面接本机的网卡接口号，如果本机有多个网卡，那么就需要区分你想要用哪个网卡去访问目标网段，这里的接口号就是开头说的通过route print命令查看到的。

例如我的24号接口能够通到目标网段，那么这里就输入24；

“-p”这个参数表示该条路由永久生效。如果不加这个参数，那么需要注意，你的这条路由在本机重启后将会失效。

route delete 192.168.19.0 mask 255.255.255.0

route add 192.168.19.0 mask 255.255.255.0 192.168.19.1 if 7 -p
相机99.186想要连接虚拟机19.129 就让网关19.1 转发

linux route命令
#添加一条路由(发往192.168.62这个网段的全部要经过网关192.168.1.1)
route add -net 192.168.62.0 netmask 255.255.255.0 gw 192.168.1.1

#删除一条路由　删除的时候不用写网关
route del -net 192.168.122.0 netmask 255.255.255.0

route add -net 192.168.19.0 netmask 255.255.255.0 gw 192.168.99.224

route add 192.168.19.0 mask 255.255.255.0 0.0.0.0 if 7 -p

开发板要ping通虚拟机，与其设置各种路由，不如让虚拟机和开发置于同一个路由网段下，设置虚拟机的网络配置器为 桥接模式

newifi_b889  puwell007

	
g++ -v -E -x c++ -

/home/mars/test/.vscode/c_cpp_properties.json

                "/usr/include/c++/11",
                "/usr/include/x86_64-linux-gnu/c++/11",
                "/usr/include/c++/11/backward",
                "/usr/lib/gcc/x86_64-linux-gnu/11/include",
                "/usr/local/include",
                "/usr/include/x86_64-linux-gnu",
                "/usr/include"


1. vscode全局搜索 (可搜代码，文件等)

Windows:

Ctrl+Shift+F

怎么调试，能用断点吗还是只能靠日志理解调用顺序
日志是哪个路径？

cp /tmp/log/host.log.bak /tmp/nfs_share/zrtx.log
cp /media/log/host.log1 /tmp/nfs_share/zrtx.log

export LD_LIBRARY_PATH=/media/usr/lib:$LD_LIBRARY_PATH
./usr/bin/gdb  zrt_app_debug

export LD_LIBRARY_PATH=/tmp/nfs_share/allwinner_gdb/usr/lib:$LD_LIBRARY_PATH
/tmp/nfs_share/allwinner_gdb/usr/bin/gdb -e zrt_app -s dbg_zrt_app -c coredump

chmod -R 777 /tmp/nfs_share/

 1 编译
gcc -g -o foo foo.c

2 生成单独的调试信息文件
objcopy --only-keep-debug foo foo.dbg

3 去除调试信息
objcopy --strip-debug --strip-unneeded foo

加载分离的符号表调试  
gdb -e foo -s foo.dbg

去除所有符号信息
要从 main 可执行文件中去除所有符号信息，直接运行：
strip main
这会从 main 文件中去除所有符号信息，包括调试信息和其他符号表信息。

去除特定类型的符号信息
如果你希望仅去除调试信息而保留其他符号，可以使用 --strip-debug 选项：
strip --strip-debug main
这样会仅去除调试符号，但保留其他符号信息，如函数名和全局变量名。


ZRT_MgrSignIn  ZRT_CLD_Obj()

ZRT_MgrMsgProc ZRT_MEDIA_Obj()

top
ps aux|grep 2761 #2761是PID值

C:\Users\admin\AppData\Roaming\Subversion
# enable-auto-props = no

调用全志api取帧发送到队列
ZRT_GetEncStreamThread
AW_MPI_VENC_GetStream
ZRT_StreamProc
ZRT_MEDIA_VIDEO_SEND
ZRT_Msg_SendInstantMsg
ZRT_MEDIA_VideoSend_Proc
ZRT_Queue_AddToTail

从队列取帧存卡、云、推流
ZRT_VideoPackAndSend
ZRT_GetFrame

./configure CC="/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc" --host=arm-openwrt-linux-muslgnueabi --prefix=$PWD/build
./configure --prefix=$PWD/build

./configure CC="/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc" --host=arm-openwrt-linux-muslgnueabi --prefix=$PWD/build CFLAGS=-static

./configure CC="/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc" --host=arm-openwrt-linux-muslgnueabi --prefix=$PWD/build CFLAGS=-static LDFLAGS="-L/extern/v853/out/v851se-perf1/staging_dir/target/usr/lib/"



升级固件 把固件PUWELL_PA_Q851SE+8188_16M_V7.02.81_20230802.bin改名为gbl_rootfs.bin，放到sd卡里，启动Daemon
/media/gbl_rootfs.bin
/usr/bin/Daemon_app &

umount /media
./fsck.fat -awy /dev/mmcblk0p1 &
mount  /dev/mmcblk0p1  /media

/tmp/nfs_share/dosfstools-4.2/build/sbin/fsck.fat -a /dev/mmcblk0p1 &


udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share

        sleep 17
        echo "iperf start"
        /media/iperf3/iperf_run.sh &


/tmp/nfs_share/dosfstools-4.2/build/sbin/fsck.fat -a /dev/mmcblk0p1

df -h 查看磁盘容量

fsck.fat32.project-main
Usage: ./myfsck <options> <disk_name>
options:
-i: show all information
-s: show only reserved sectors
-f: show only files

另外两个编译不过

查看环境变量
export

winhex

sc create svnservice binpath="C:\install\svn\bin\svnserve.exe --service -r C:\svn_repo" depend=Tcpip start=auto
sc delete svnservice

services.msc
svn://192.168.99.224

svn checkout svn://192.168.99.224/dostool_fsck --username mars --password tt
svn checkout svn://192.168.99.224/dostool_fsck ./fsck_bk --username mars --password tt #检出到指定的fsck_bk目录
svn checkout https://192.168.10.195:448/svn/Qz-IPC/trunk/tina-v853 ./v853 --username zhongxt --password 123456
svn export https://192.168.10.195:448/svn/Qz-IPC/trunk/tina-v853 ./v853 --username zhongxt --password 123456

svn checkout svn://192.168.10.246/server/Qz-SDK ./qzsdk --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libonvif ./onvif --username zhongxt --password 123456

svn checkout https://192.168.10.195:448/svn/ipc/trunk/librtsp/LIBRTSPRTP_V1.0.0.0_R20130603 ./rtsplib --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libhttp/LIBHTTP_V1.0.0.0_R20130603 ./http --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libinfra/LIBINFRA_V1.0.0.0_R20130603 ./thread_and_mutex --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libstream_reader/LIBSTREAMREADER_V1.0.0.0_R20130603 ./stream_reader --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libtpbase/LIBTPBASE_V1.0.0.0_R20130603 ./tpbase --username zhongxt --password 123456
svn checkout https://192.168.10.195:448/svn/ipc/trunk/libtpbase_x/LIBTPBASE_X_V1.0.0.0_R20190306 ./tpbase_x --username zhongxt --password 123456

svn checkout svn://192.168.10.246/server/Qz-SDK ./packapp --username zhongxt --password 123456


将一个文件夹下的所有内容复制到另一个文件夹下
cp -r /home/packageA/* /home/cp/packageB/


在/etc/profile文件中添加变量【对所有用户生效（永久的）】  

用vim在文件/etc/profile文件中增加变量，该变量将会对Linux下所有用户有效，并且是“永久的”。  

例如 增加下列变量
export wksp=/home/mars/workspace
export mars=/home/mars
export nfss=/home/mars/nfs_share
export qz_toolchain=/home/mars/workspace/code/Qz-SDK/cross_compiler/toolchain

要让刚才的修改马上生效，需要执行以下代码  
source /etc/profile  

删除环境变量:
unset xxxxx

pidof 程序名称（进程名） 查看某一程序的进程号
ps -aux | grep redis 查看redis 进程信息
ps -eo pid,comm,rss,vsz |grep 进程名  (其中-rss和-vsz分别是该 进程 所 占用 的实际 内存 和虚拟 内存 大小，单位是KB。)

cat >test 创建test文件 ctrl+D退出

svn up -r3 回退到3版本
svn up 更新到最新版本
svn 远端根目录新增了一个文件夹，我只想把这个文件夹更新下来，应该怎么做?
要将远程仓库中新增的特定文件夹更新到本地，您可以使用以下命令：

svn update new_dir

valgrind --tool=memcheck --leak-check=full ./fsck.fat -a check-bad_names.img 检测内存泄漏
VALGRIND_LIB=/media/allwinner_gdb/usr/lib/valgrind /media/allwinner_gdb/usr/bin/valgrind --tool=memcheck --leak-check=full /media/zrt_app

sh -x xxxx.sh param1 param2 调试sh脚本

qt安装器下载 https://www.qt.io/download-qt-installer-oss?hsCtaTracking=99d9dd4f-5681-48d2-b096-470725510d34%7C074ddad0-fdef-4e53-8aa8-5e8a876d6ab4

linux 安装qt
运行这个 qt-unified-linux-x64-4.6.0-online.run，缺库就安装库

linux QT 开发 要cmake能找到qt的组件，需要安装下面两个库
apt-get install build-essential libgl1-mesa-dev

cmake -DCMAKE_PREFIX_PATH=/opt/Qt/6.5.1/gcc_64 ..

安装ffmpeg
1、下载解压

wget http://www.ffmpeg.org/releases/ffmpeg-3.1.tar.gz
tar -zxvf ffmpeg-3.1.tar.gz 
2、 进入解压后目录,输入如下命令/usr/local/ffmpeg为自己指定的安装目录

cd ffmpeg-3.1
./configure --prefix=/usr/local/ffmpeg
make && make install

wget http://www.tortall.net/projects/yasm/releases/yasm-1.3.0.tar.gz
tar -zxvf yasm-1.3.0.tar.gz
cd yasm-1.3.0
./configure
make && make install

cmake -DCMAKE_CXX_COMPILER=C:\mingw64\bin\g++ -DCMAKE_C_COMPILER=C:\mingw64\bin\gcc 

"C:\Program Files\CMake\bin\cmake.exe" --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=C:\msys64\mingw64\bin\gcc.exe -DCMAKE_CXX_COMPILER:FILEPATH=C:\msys64\mingw64\bin\g++.exe -SC:/workspace/pwdecrypt -Bc:/workspace/pwdecrypt/build -G "MinGW Makefiles" -DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64
-DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64

"C:\Program Files\CMake\bin\cmake.exe" --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Debug -DCMAKE_C_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\gcc.exe -DCMAKE_CXX_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\g++.exe -SC:/workspace/pwdecrypt -Bc:/workspace/pwdecrypt/build -G "MinGW Makefiles" -DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64

"C:\Program Files\CMake\bin\cmake.exe" --no-warn-unused-cli -DCMAKE_EXPORT_COMPILE_COMMANDS:BOOL=TRUE -DCMAKE_BUILD_TYPE:STRING=Release -DCMAKE_C_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\gcc.exe -DCMAKE_CXX_COMPILER:FILEPATH=C:\Qt\Tools\mingw1120_64\bin\g++.exe -SC:/workspace/pwdecrypt -Bc:/workspace/pwdecrypt/build -G "MinGW Makefiles" -DCMAKE_PREFIX_PATH=C:\Qt\6.5.1\mingw_64
windows 安装新版的mingw
先安装msys2 
然后设置源
然后 pacman -S --needed base-devel mingw-w64-x86_64-toolchain 


C:\Qt\Tools\CMake_64\bin\cmake.exe -S C:/workspace/pwdecrypt1 -B C:/workspace/pwdecrypt1/build "-DCMAKE_GENERATOR:STRING=Ninja" "-DCMAKE_BUILD_TYPE:STRING=Debug" "-DCMAKE_PROJECT_INCLUDE_BEFORE:FILEPATH=C:/workspace/pwdecrypt1/build.qtc/package-manager/auto-setup.cmake" "-DQT_QMAKE_EXECUTABLE:FILEPATH=C:/Qt/6.5.1/mingw_64/bin/qmake.exe" "-DCMAKE_PREFIX_PATH:PATH=C:/Qt/6.5.1/mingw_64" "-DCMAKE_C_COMPILER:FILEPATH=C:/Qt/Tools/mingw1120_64/bin/gcc.exe" "-DCMAKE_CXX_COMPILER:FILEPATH=C:/Qt/Tools/mingw1120_64/bin/g++.exe" "-DCMAKE_CXX_FLAGS_INIT:STRING=-DQT_QML_DEBUG" 

fdisk -l
lsblk


/dev/sdb

/home/mars/svn_workspace/fsck_bk/build/sbin


udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share
cd /tmp/nfs_share/scripts
./first


udhcpc
mkdir /tmp/nfs_share
mount -o vers=4 192.168.99.193:/home/mars/nfs_share /tmp/nfs_share
cd /tmp/nfs_share/scripts
./second


./configure --prefix=/server/nginx --with-http_ssl_module --with-http_sub_module --add-module=../nginx-upload-module-2.3.0

apt-get install libpcre3-dev  #pcre 错误
apt-get install libssl-dev   #openssl 错误
apt-get install zlib1g-dev

chmod 666 file/folder 表示所有用户都可以读写但不能执行文件/文件夹;
chmod 777 file/folder 允许所有用户的所有操作(一般的暴力解决办法)
chmod 744 file/folder 只允许用户(所有者)执行所有操作;组和其他用户只允许阅读。


nginx -s reload

location / {
            root   C:\Uploads;
            autoindex on;                            
			autoindex_exact_size off;            
			autoindex_localtime on;            
        }

location /upload {
            # Pass altered request body to this location
            #upload_pass   @test;

            # Store files to this directory
            # The directory is hashed, subdirectories 0 1 2 3 4 5 6 7 8 9 should exist
            upload_store /upfiles 1;
            
            # Allow uploaded files to be read only by user
            upload_store_access user:r;

            # Set specified fields in request body
            upload_set_form_field "${upload_field_name}_name" $upload_file_name;
            upload_set_form_field "${upload_field_name}_content_type" $upload_content_type;
            upload_set_form_field "${upload_field_name}_path" $upload_tmp_path;

            # Inform backend about hash and size of a file
            upload_aggregate_form_field "${upload_field_name}_md5" $upload_file_md5;
            upload_aggregate_form_field "${upload_field_name}_size" $upload_file_size;

            upload_pass_form_field "^submit$|^description$";
        }

        # Pass altered request body to a backend
        location @test {
            proxy_pass   http://localhost:8288;
        }


        location /upload {
            # Pass altered request body to this location
            upload_pass   /example.php;

            # Store files to this directory
            # The directory is hashed, subdirectories 0 1 2 3 4 5 6 7 8 9 should exist
            upload_store /upfiles 1;
            
            # Allow uploaded files to be read only by user
            upload_store_access user:r;

            # Set specified fields in request body
            upload_set_form_field "${upload_field_name}_name" $upload_file_name;
            upload_set_form_field "${upload_field_name}_content_type" $upload_content_type;
            upload_set_form_field "${upload_field_name}_path" $upload_tmp_path;

            # Inform backend about hash and size of a file
            upload_aggregate_form_field "${upload_field_name}_md5" $upload_file_md5;
            upload_aggregate_form_field "${upload_field_name}_size" $upload_file_size;

            upload_pass_form_field "^submit$|^description$";
        }

        # Pass altered request body to a backend
        #location @test {
        #    proxy_pass   http://localhost:8080;
        #}
        location ~ \.php$ {
     		root           html/upload;
     	  	fastcgi_pass   127.0.0.1:9000;
     		fastcgi_index  index.php;
	        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        	include        fastcgi_params;
  	  }


ps -aux | grep nginx


var http = require('http'); 
var fs = require('fs'); 
var formidable = require('formidable'); 
 
// 包含上传表单的html文件
var upload_html = fs.readFileSync("/server/nginx/html/upload.html"); 
 
// 将其替换为保存上传文件的位置
var upload_path = "/upfiles/"; 
 
http.createServer(function (req, res) { 
    if (req.url == '/uploadform') { 
      res.writeHead(200); 
      res.write(upload_html); 
      return res.end(); 
    } else if (req.url == '/fileupload') { 
        var form = new formidable.IncomingForm(); 
        form.parse(req, function (err, fields, files) { 
            // oldpath：文件保存到的临时文件夹
            var oldpath = files.filetoupload.filepath; 
            var newpath = upload_path + files.filetoupload.name; 
            // 将文件复制到新位置
            fs.rename(oldpath, newpath, function (err) { 
                if (err) throw err; 
                // 您可能会用另一个html页面进行响应
                res.write('File uploaded and moved!'); 
                res.end(); 
            }); 
        }); 
    }  
 }).listen(8086);


curl 192.168.99.224:80/xxfcgi -F "file=@/home/mars/someth/text.t" -H "FILE_NAME: text.t" -v

curl localhost:6565/decrypt/upload/ -X POST -d "title=comewords&content=articleContent" -v

curl -X PUT -T /extern/test/test.c http://192.168.1.197/upload/test-file.cc

underscores_in_headers on;

location /xxfcgi{
			fastcgi_pass        192.168.99.193:6565;
			fastcgi_param REQUEST_METHOD $request_method;
			client_max_body_size 100m;
		}

静态链接需要注意顺序，A程序依赖B库，B库依赖C库 那么A的makefile文件里链接顺序是 -lB -lC 是一种回溯的关系

GLOB_RECURSE会把build目录里的cpp和h拉进来，需要去掉

file(GLOB_RECURSE PROJECT_SOURCES ${CMAKE_SOURCE_DIR}/*.cpp ${CMAKE_SOURCE_DIR}/*.h)
file(GLOB_RECURSE BUILD_CODE "build/*.cpp" "build/*.h")
list(REMOVE_ITEM PROJECT_SOURCES ${BUILD_CODE})

./fcgi_de264 -p 6565 -d /decrypt264/

-s /decrypt264/14-10-00(002ea52b).264 -u 158897 -d 1007710900

./decrypt -s /decrypt264/14-10-00\(002ea52b\).264 -u 158897 -d 1007710900

"158897", "1007710900"

<p>
            <a href="/download/t.txt" download="文件名.txt">点击下载</a>
        </p>

查看可执行程序依赖的库： objdump -x 可执行程序名| grep NEEDED.

库的链接时路径和运行时路径

    现代连接器在处理动态库时将链接时路径（Link-time path）和运行时路径（Run-time path）分开,用户可以通过-L指定连接时库的路径，通过-R（或-rpath）指定程序运行时库的路径，大大提高了库应用的灵活性。

-Wl,-rpath=./ 
-Wl表示链接时将当前目录传递
-rpath表示运行时搜索当前目录

程序部署不能直接将二进制文件拷贝到目标机器或服务器上，需要先找到目标机器的工具链交叉编译打包，才能部署

利用__attribute__((section()))构建初始化函数表

ZRT_WIFI_MODE

make
cp zrt_app $nfss -v

vscode debug launch.json 
{
    "configurations": [
        {
            "name": "(gdb) 启动",
            "type": "cppdbg",
            "request": "launch",
            "program": "${workspaceFolder}/fcgi_de264",
            "args": [],
            "stopAtEntry": false,
            "cwd": "${fileDirname}",
            "environment": [],
            "externalConsole": false,
            "MIMode": "gdb",
            "setupCommands": [
                {
                    "description": "为 gdb 启用整齐打印",
                    "text": "-enable-pretty-printing",
                    "ignoreFailures": true
                },
                {
                    "description": "将反汇编风格设置为 Intel",
                    "text": "-gdb-set disassembly-flavor intel",
                    "ignoreFailures": true
                }
            ]
        }
    ],
    "version": "2.0.0"
}

ffmpeg -i "C:\testdata\14-10-00(002ea52b)-decrypted0.mp4" -vcodec copy -an -bsf:v h264_mp4toannexb  "C:\testdata\raw.h264"

其中：

-i是输入文件名

-vcodec copy是指直接解复用，不解码，copy到目的文件

-an audio none，禁用音频文件

-bsf:v h264_mp4toannexb mp4有两种startCode模式，这里用annexb模式。

fw_printenv mac


pip3 install torch torchvision torchaudio
2.0.1+cpu

cp -r /home/mars/nfs_share/upload_pic /mnt/hgfs/share/

#define UPLOAD_PIC_PATH "/config/upload_pic/"
static int count=0;
void file_write(char* filepath,char* buf,int len){
	FILE* fp = fopen(filepath, "wb");
	if(!fp) return;
    fwrite(buf, len, 1, fp);
	fclose(fp);
	ZRT_LOG_INFO("write file %s\n",filepath);
	count++;
}


char* file_read(char* filepath,int *size)
{
	FILE *fp = fopen(filepath, "rb");
	if (!fp)
		return 0;
	fseek(fp, 0, SEEK_END);
	*size = ftell(fp);
	fseek(fp, 0, SEEK_SET);
	char *tmp = (char *)malloc(*size * sizeof(char));
	fread(tmp, *size, 1, fp);
	ZRT_LOG_INFO("read file %s, size: %d\n",filepath, *size);
	return tmp;
}



	int file_len = 0;
	char *pic1 = file_read("/config/fire/fire1.jpg", &file_len);
	Picture_Server_Upload(obj, pic1, file_len);
	free(pic1);

	sleep(1);
	char *pic2 = file_read("/config/fire/fire2.jpg", &file_len);
	Picture_Server_Upload(obj, pic2, file_len);
	free(pic2);
	
	return 0;

if (res_body && (res_body->reco_info.lKindNo & (1 << FIRE)))
			{
				ZRT_LOG_INFO("detect fire, alarm\n");
			}
			ZRT_LOG_INFO("AI_RECOGNITION: %d\n",res_body->reco_info.lKindNo);


40:6A:8E:FF:29:01

fw_printenv mac

406A8EFF2901

VALGRIND_LIB=/media/usr/lib/valgrind ./usr/bin/valgrind zrt_app


 shared libraries: libstdc++.so.6: cannot open shared object file

 apt-get install lib32stdc++6

 为/root目录创建软连接
[root@localhost ~]# ln -s /root /etc/root1



export LD_LIBRARY_PATH=/media/usr/lib:$LD_LIBRARY_PATH
./usr/bin/gdb  zrt_app_debug

gdb调试 coredump 
gdb program coredump
例如 /media/usr/bin/gdb /media/zrt_app /media/coredump_974_ZRT_MediaDataTh
usr/bin/gdb -e x_app -c coredump_872_x_app -s x.dbg
调试包含调试信息的程序，不要加-e参数，会导致读不到符号信息
可以使用以下命令在GDB中传递参数
run arg1 arg2 ...

wpa_supplicant -Dnl80211 -iwlan0 -c/media/wpa_supplicant.conf -B
./wpad wpa_supplicant -Dnl80211 -iwlan0 -c/media/wpa_supplicant.conf -B


wpa_cli -i wlan0 scan              #扫描附近热点
wpa_cli -i wlan0 scan_result       #打印热点信息

wpa_cli -i wlan0 add_network       # 添加一个网络连接,并返回网络ID号,如果wpa_supplicant.conf文件为空,则返回0,表示第一个热点,然后该ID号会在连接热点用到
wpa_cli -i wlan0 set_network 0 ssid '"Redmi_87C0_2G"'    #设置ID为0的热点SSID
wpa_cli -i wlan0 set_network 0 psk '"88888888"'    #设置ID为0的热点的密码

如果是没有加密的公共网络,则输入以下密码:
wpa_cli -i wlan0 set_network 0 key_mgmt NONE

wpa_cli -i wlan0 get_capability key_mgmt

wpa_cli -i wlan0 set_network 0 priority 2     //设置当前网络优先级,默认为2
wpa_cli -i wlan0 set_network 0 scan_ssid 1    //设置ssid默认为1即可
wpa_cli -i wlan0 enable_network 0            //启动连接ID为0的网络

wpa_cli -i wlan0 select_network 0             //选择网络0(这样做的好处在于,可以取消先前的其它网络连接)

udhcpc -b -i wlan0 -q    
         //此时只是连接上,所以还要自动分配IP地址,-b:后台(back) –i:指定接口 –q:获得续约后退出

wpa_cli -i wlan0 set_network 0 ieee80211w 2
wpa_cli -i wlan0 set_network 0 key_mgmt SAE


wpa_cli -i wlan0 save_config    //保存当前连接的网络配置到wpa_supplicant.conf文件中,使得下次自动连接

从文件中获取wlan0的网卡地址
cat /sys/class/net/wlan0/address


完整的联网流程
wpa_supplicant -B -Dnl80211 -iwlan0 -c/etc/wpa_supplicant.conf

wpa_cli -i wlan0 add_network
wpa_cli -i wlan0 set_network 0 ssid '"newifi_b889"'
wpa_cli -i wlan0 set_network 0 psk '"puwell007"'
wpa_cli -i wlan0 select_network 0 
wpa_cli -i wlan0 enable_network 0 
udhcpc -iwlan0
====================================================================
wpa_supplicant -B -Dnl80211 -iwlan0 -c/etc/wpa_supplicant.conf

wpa_cli -i wlan0 add_network
wpa_cli -i wlan0 set_network 0 ssid '"TP123"'
wpa_cli -i wlan0 set_network 0 psk '"12345678"'
wpa_cli -i wlan0 select_network 0 
wpa_cli -i wlan0 enable_network 0 
udhcpc -iwlan0

====================================================================
wpa_supplicant -B -Dnl80211 -iwlan0 -c/etc/wpa_supplicant.conf

wpa_cli -i wlan0 add_network
wpa_cli -i wlan0 set_network 0 ssid '"F017"'
wpa_cli -i wlan0 set_network 0 psk '"0123456789"'
wpa_cli -i wlan0 select_network 0 
wpa_cli -i wlan0 enable_network 0 
udhcpc -iwlan0

 mkdir /tmp/nfs_share
 mount -o vers=4 192.168.0.111:/home/mars/nfs_share /tmp/nfs_share


./sev_net_test_cli_arm 23456 192.168.10.142 12345

./rtwpriv wlan0 efuse_set wmap,10,2D2D2E2E2F2F29292B2D2D
./rtwpriv wlan0 efuse_set wmap,10,2727282829292727292B2B
./rtwpriv wlan0 efuse_get realmap

占用ip的方法 先用udhcpc动态获取ip，再用ifconfig设置ip
udhcpc
#设置ip为192.168.99.120
ifconfig eth0 192.168.99.120 netmask 255.255.255.0 

/etc/init.d/run.sh


root@(none):~# wpa_cli -i wlan0 enable_network 0   
OK
root@(none):~# [10751.912927] RTW: wlan0- hw port(0) mac_addr =c4:3c:b0:74:bc:d3
[10751.920170] RTW: wlan1- hw port(1) mac_addr =c6:3c:b0:74:bc:d3
[10751.938753] RTW: nolinked power save leave
wlan0: Trying to associate with [10753.807064] RTW: rtw_set_802_11_connect(wlan0)  fw_state=0x00000000
a4:39:b3:76:b8:41 (SSID='Redmi_87C0' freq=2442 MHz)
[10753.941748] RTW: start auth
[10753.957093] RTW: auth success, start assoc
[10754.015454] RTW: assoc success
wlan0: Associated with a4:39:b3:76:b8:41
wlan0: CTRL-EVENT-SUBNET-STATUS-UPDATE status=0
[10754.027674] RTW: ============ STA [a4:39:b3:76:b8:41]  ===================
[10754.036168] RTW: mac_id : 0
[10754.039288] RTW: wireless_mode : 0x0b
[10754.043418] RTW: mimo_type : 0
[10754.046993] RTW: bw_mode : 20MHz, ra_bw_mode : 20MHz
[10754.052584] RTW: rate_id : 3
[10754.055818] RTW: rssi : 56 (%), rssi_level : 0
[10754.060798] RTW: is_support_sgi : Y, is_vht_enable : N
[10754.066549] RTW: disable_ra : N, disable_pt : N
[10754.071621] RTW: is_noisy : N
[10754.074942] RTW: txrx_state : 0
[10754.078540] RTW: curr_tx_rate : CCK_1M (L)
[10754.083146] RTW: curr_tx_bw : 20MHz
[10754.087053] RTW: curr_retry_ratio : 0
[10754.091153] RTW: ra_mask : 0x00000000000fffff
[10754.091153] 
[10754.148732] RTW: recv eapol packet
[10754.153059] RTW: send eapol packet
[10754.170472] RTW: recv eapol packet
[10754.174607] RTW: send eapol packet
[10754.178822] RTW: set pairwise key camid:0, addr:a4:39:b3:76:b8:41, kid:0, type:AES
wlan0: WPA: Key negotiation comp[10754.188011] IPv6: ADDRCONF(NETDEV_CHANGE): wlan0: link becomes ready
leted with a4:39:b3:76:b8:41 [PTK=CCMP GTK=CCMP]
wlan0: CTRL-EV[10754.201193] RTW: set group key camid:1, addr:a4:39:b3:76:b8:41, kid:1, type:AES
ENT-CONNECTED - Connection to a4:39:b3:76:b8:41 completed [id=0 id_str=]


apt-get install  libncurses5-dev gawk

multiple definition of `yylloc` gcc版本过高

find . -name "wpad"|xargs -i ls -l {}

find . -name "test*"|xargs -i cp {} /media

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media/iperf3

vscode  Ctrl+D 选词


ssh win免密登录linux设置
1 生成密钥对 将在C:\User\name\.ssh 目录下生成
2 将公钥内容拷贝到linux服务器的 ~/.ssh/authorized_keys文件中
3 用ssh root@192.168.x.x -i C:\User\name\.ssh\id_rsa 测试登录

IdentityFile "C:\Users\admin\.ssh\id_rsa"

/v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY

vscode 的缓存文件 都存在这里 C:\Users\admin\AppData\Roaming\Code

C:\Users\admin\AppData\Roaming\Code\User\workspaceStorage

生成一个10m的文件
dd if=/dev/zero of=./file.txt bs=1M count=10 

 ./iperf3 -c 192.168.99.224 -u -b 100M -f M
 ./iperf3 -c 192.168.99.224 

 SDK_DIR=/extern/v853
PROJECT_DIR=/home/mars/workspace/code/qzsdk

/media/iperf3/iperf_run.sh &

恢复sdk默认配置
target\allwinner\v851se-perf1/defconfig 

打包出错了先用make看一下具体哪里报错，因为打包用的是make -j32多线程编译
一般的，可以先清理mpp 然后再mkmpp
cleanmpp
mkmpp
成功后再make -j32一般没问题
mboot 编译boot0和uboot
mkernel 编译内核
mkmpp 编译mpp库
svn 清理掉多余文件直接make -j32编译，不需要make menuconfig关闭sample选项

source ./build/envsetup.sh
        lunch 5


svn revert --recursive .
#svn 还原当前文件夹，可以在子文件夹使用，将只作用与子文件夹
svn revert -R . 

svn st | grep '^?' | awk '{print $2}' | xargs rm -rf 清理（删除）未跟踪文件

svn info 查看当前版本
svn status 查看更改的文件
svn diff -r 28:25 [something]
svn update -r [版本号] 回滚到指定版本

要查看远程版本库的日志并限制为5个记录，可以使用以下命令：

svn log -l 5 <远程目录URL>

svn update -r 283

echo '1:2:3' |tr -d : #用tr命令删除输出的字符串中:  
cat test.txt |tr -d : #用tr命令删除输出的字符串中:  
echo '1:2:3' |tr ':' ',' #用tr命令替换输出的字符串中:  

C:sshkey/key tt

解决这种问题需要进行设置,不让他自动转义,执行命令(命令的意思是开启目录扩展,-s是打开):
shopt -s direxpand

在~/.bashrc文件后加入shopt -s direxpand一行
然后 source ~/.bashrc可全局生效

export LD_LIBRARY_PATH=/media/usr/lib:$LD_LIBRARY_PATH
./usr/bin/gdb  zrt_app_debug
/media/usr/bin/gdb -e zrt_app -s zrt_app.debug -c coredump_


md5sum 

VERSION=7.02.93test


BUILD_SDK=y
BUILD_MPP=n
BUILD_PACKUPDATE=n
BUILD_LIBS=n
BUILD_DAEMON=n
BUILD_APP=y
BUILD_FUSE=n
BUILD_PRODUCTION=n
BUILD_TESTBOARD=n


SDK_DIR=/extern/v853
PROJECT_DIR=/home/mars/workspace/code/package

pack/8M/rootfs/build_rootfs.sh
#rm ./etc/init.d/S50netadb

简化find命令
alias findx='/command/find.sh'
find.sh脚本
#set -x
#path=$(readlink -f $1)
#echo $path
if [ $# != 2 ];then
       exit
fi
if [ -z $1 ] || [ -z "$2" ]; then
        echo param is null p1=$1 p2=$2
else
        find $1 -name "$2"
fi

makefile make不是执行all目标而是执行第一个目标，所以一般把all目标放在第一个位置

"workbench.colorCustomizations": {
        //"editor.selectionHighlightBorder": "#00ff15", // 高亮
        "editor.selectionBackground": "#f003ffa6",
        //"editor.selectionForeground": "#404245",
        //"editor.selectionHighlightBackground": "#098709",

        "editor.wordHighlightBackground": "#1c5e84a5",
        "editor.wordHighlightBorder": "#00ff0d",
        //"editor.wordHighlightStrongBackground": "#ff0000",
        //"editor.wordHighlightStrongBorder": "#ff0000",
        //"editor.wordHighlightTextBackground": "#ff0000",
        //"editor.wordHighlightTextBorder": "#ff0000",
        
        "editor.findMatchBackground": "#f003ffa6",//搜索匹配的背景色
        "editor.findMatchHighlightBackground": "#f003ffa6",
        //"editor.findRangeHighlightBackground": "#ff9900",
        "editorOverviewRuler.findMatchForeground": "#17ff02",//右侧滚动条高亮
        "scrollbarSlider.background": "#bba76d",
        "scrollbarSlider.hoverBackground": "#cfb56a",
        "scrollbarSlider.activeBackground": "#fbdd86"
        },



if(1 == judge_UnitCamera_device()){
		ZRT_LOG_INFO("SetAwbStatsSyncMode:ISP0_ISP1_COMBINE\n");
		AW_MPI_ISP_SetAwbStatsSyncMode(1, ISP0_ISP1_COMBINE); 
	}


h264 的i帧前面需要有spspps信息，比如我从一个相机里能得到IPPPPPPIPPPPIPPPPPP这样的原始帧数据，我要将它写入到.h264文件中并能够播放，我需要在每个I帧前插入spspps信息


if(iProfileIdx < 2 && (ZRT_ABS_hasMotor() || ZRT_ABS_isZoomCamera()))

DESCRIBE rtsp

/media/DownloadTest http://ush.ipc365.com:8080/httpdownload/download/PUWELL_PA2_Q851SE+8188_16M_V7.02.76_20230707.bin /media/xx.bin

查看目录dir下1层文件或目录所占的空间
du -h --max-depth=1 /root |sort -rh
磁盘占用太大一般是/root/.vscode-server的问题，将它删掉即可,但会丢失插件

查看固件版本
cat /etc/version.conf

perror.c

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int main(int argc, char *argv[])
{
    if (argc <= 1)
    {
        return 0;
    }
    int no = atoi(argv[1]);
    printf("errno %d: %s\n", no, strerror(no));

    return 0;
}

把程序拷贝到 /usr/local/bin/ 目录 可以被命令行调用

#define xprint(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)

-D_USE_MP4 -Dxprint\(fmt\,...\)=printf\(\"\%s:\"\"\#\#mp4\#\#\ \"fmt\"\\n\"\,__func__\,\#\#__VA_ARGS__\)


ifconfig eth0 down
ifconfig eth0 hw ether 0a:1b:b4:00:89:0e
ifconfig eth0 up

/usr/sbin/wpa_cli

目前全志系列的固件版本为：p1--变焦枪球，p3--三目拼接，p7--小蛋，7.02.XX--常规/拼接枪球，7.20.XX.T1--低功耗

wifi信息存在 /config/cfg.txt

/media/usr/bin/gdb  -e zrt_app -s zrt_app.debug -c coredump_1031_CLD_InitThread

gcc 高亮错误
-g -fdiagnostics-color=always

全志 v853芯片
格科微 gc2083 sensor
Camera Compact Module 摄像头模组
南阳禾立光电

只想看已经被修改的文件，你可以使用grep命令过滤输出，像这样：
svn status | grep '^M'
svn status | grep '\.c$'


Tina_Linux_系统软件_开发指南.pdf
Tina_Linux_多媒体MPP_开发指南.pdf



如果解密不出来可以用这个解密试试 C:\重要文档\pwdecrypt-fix

httpclient_response_parse
ZRT_LOG_INFO("%-128s\n",data);


SDK_DIR=/extern/Puwell-V853
PROJECT_DIR=/home/mars/workspace/code/qzsdk

repo清除所有修改及更新命令
repo forall -c "pwd;git clean -f;git checkout -f";repo sync -c --no-tags;repo sync -l;


patch -p1 < xx.patch 表示将xx补丁打入当前目录，并去掉前第一个路径
patch -p1 -R < xx.patch 卸载补丁
patch -p0       (“p”指的是路径，后面的数字表示去掉路径的第几部分。"0"，表示不去掉，为全路径)
patch -p1       (“p”后面的数字"1"，表示去掉前第一个路径)


15988184546 
puwell119

^(?=.*a)(?=.*b).*$  包含a且包含b的一行

	cdx_sem_t sem_gdc;
	sGdcParam gdc_param;
	int zoomH;
	int zoomV;

    // pthread_mutex_lock(&pContext->m_switchMutex);
	// if (pContext->gdc_param.bGDC_en)
	// {
	// 	cdx_sem_wait(&pContext->sem_gdc);
	// 	// ZRT_LOG_INFO("sem back\n");
	// }
	// if (2 == pContext->m_switchStatus)
	// {
	// 	if (pContext->gdc_param.bGDC_en && 
	// 	(pContext->gdc_param.zoomH == pContext->zoomH) && 
	// 	(pContext->gdc_param.zoomV == pContext->zoomV))
	// 	{
	// 		// pContext->m_switchStatus = 0;
	// 		// AW_MPI_VENC_RequestIDR(0, TRUE);
	// 	}
	// 	else
	// 	{
	// 		ZRT_LOG_INFO("drop frame\n");
	// 		// bDrop = true;
	// 		// AW_MPI_VENC_RequestIDR(0, TRUE);
	// 	}
	// }
	// pthread_mutex_unlock(&pContext->m_switchMutex); 

    // case MPP_EVENT_VENC_GDC_PREOCESS_COMPLETE:
            // {
            //     sGdcParam *gdc_param = (sGdcParam *)pEventData;
			// 	context_t *pContext = (context_t *)cookie;

            //     memcpy(&pContext->gdc_param, gdc_param, sizeof(sGdcParam));
            //     // ZRT_LOG_INFO("call back\n");
            //     cdx_sem_up(&pContext->sem_gdc);
            // }
    int ZRT_Switch_Enc(context_t *pContext, int target_sensor, GSRECT stNextRoi)


/mnt/UDISK/language/video_close.g711a
/mnt/UDISK/language/dingdong.g711a
/mnt/UDISK/language/ap_mode.g711a
/mnt/UDISK/language/alarm.g711a
/mnt/UDISK/language/smoke.g711a
/mnt/UDISK/language/call.g711a
/mnt/UDISK/language/motion.g711a
/mnt/UDISK/language/net_connect.g711a
/mnt/UDISK/language/upgrade_start.g711a
/mnt/UDISK/language/dhcp_getip_failed.g711a
/mnt/UDISK/language/upgrade_success.g711a
/mnt/UDISK/language/video_open.g711a
/mnt/UDISK/language/upgrade_fail.g711a
/mnt/UDISK/language/input_ssid.g711a
/mnt/UDISK/language/passwd_err.g711a
/usr/bin/VoiceCN/dhcp_getip_failed.g711a
/usr/bin/VoiceCN/net_connect.g711a
/usr/bin/VoiceCN/passwd_err.g711a
/usr/bin/VoiceCN/upgrade_fail.g711a
/usr/bin/VoiceCN/upgrade_start.g711a
/usr/bin/VoiceCN/upgrade_success.g711a
/usr/bin/VoiceCN/video_close.g711a
/usr/bin/VoiceCN/video_open.g711a
/usr/bin/VoiceEN/dhcp_getip_failed.g711a
/usr/bin/VoiceEN/net_connect.g711a
/usr/bin/VoiceEN/passwd_err.g711a
/usr/bin/VoiceEN/upgrade_fail.g711a
/usr/bin/VoiceEN/upgrade_start.g711a
/usr/bin/VoiceEN/upgrade_success.g711a
/usr/bin/VoiceEN/video_close.g711a
/usr/bin/VoiceEN/video_open.g711a
/usr/bin/VoiceGeneral/ap_mode.g711a
/usr/bin/VoiceGeneral/call.g711a
/usr/bin/VoiceGeneral/dingdong.g711a
/usr/bin/VoiceGeneral/input_ssid.g711a
/usr/bin/VoiceGeneral/motion.g711a
/usr/bin/VoiceGeneral/smoke.g711a

/media/tcp_client 16663 1 /usr/bin/VoiceGeneral/ap_mode.g711a
/media/tcp_client 16663 1 /usr/bin/VoiceCN/net_connect.g711a
/media/tcp_client 16663 1 /usr/bin/VoiceCN/dhcp_getip_failed.g711a

159881
1009873167
日志搜索device_id camera_id 获取设备id


for(i = 0; i < g_stAllFocus.lNum; i++)
        {
            ZRT_LOG_DBG("Area = %d, mask x,y = [%f, %f], region = [%d,%d,%d,%d]\n", 
        g_stAllFocus.pstTarList[i].lArea,
        g_stAllFocus.pstTarList[i].stCentroidF.x, g_stAllFocus.pstTarList[i].stCentroidF.y,
        g_stAllFocus.pstTarList[i].stRegion.left, g_stAllFocus.pstTarList[i].stRegion.top, g_stAllFocus.pstTarList[i].stRegion.right, g_stAllFocus.pstTarList[i].stRegion.bottom);
        }

        ZRT_Motion_OsdUpdate_v2(1, 0, GUN_OSD, (void*)&g_stAllFocus);


certutil -hashfile "C:\path\to\your\file" MD5

/config/unitcam.cfg

/extern/v853/lichee/linux-4.9/drivers/media/platform/sunxi-vin/modules/sensor


int ShakeCtrl::__Ptz_set_target_degree(int pan_degree, int is_pan_speed_gear, int tilt_degree, int is_tilt_speed_gear)
{
    int ret = 0;
    if(Ptz_motor_is_stop(PTZ_PAN) == 0 || Ptz_motor_is_stop(PTZ_TILT) == 0)
    {
        //对可能存在的异常做处理。如果剩余很多负数的(或者圈数寄存器是0)，则可能是芯片寄存器
		//没更新到，先暂时不处理，等待下次恢复正常在处理
        if((ret = Ptz_onestep_stop(NULL)) < 0)
        {
            printf("[%s:%d]: ptz motor is not update\n", __FUNCTION__, __LINE__);
            return -1;
        }
    }
    
    Ptz_motor_set_speed(21);
    // Ptz_motor_set_speed(m_ShakeCtrlInfo.MotorConfig.lStepFreq);


echo 96  > /sys/class/gpio/export
echo out > /sys/class/gpio/gpio96/direction
echo 1 > /sys/class/gpio/gpio96/value

cat /sys/kernel/debug/mpp/isp
cat /sys/kernel/debug/mpp/ve_*
cat /sys/kernel/debug/mpp/vi

ffmpeg -f alaw -ar 8000 -ac 1 -i upgrade_start.pcma -vcodec copy test.mp4

检查有没有进产测 搜wlan0 如果有很多信息打印就是进了 还可以搜factory如果很多factory函数打印就是进了

ffplay -f alaw -ac 1 -ar 8000 -i avps.ps

	.AEncattr.AeAttr.sampleRate = 8000,
	.AEncattr.AeAttr.channels = 1,	
	.AEncattr.AeAttr.bitRate = 0,
	.AEncattr.AeAttr.bitsPerSample = 16,
	.AEncattr.AeAttr.attachAACHeader = 1,
	.AEncattr.AeAttr.Type = PT_G711A,



ffmpeg -f alaw -ar 8000 -ac 1 -i rec.g711a -acodec copy output.mpg

ffmpeg -i mpeg2-pcm-misdetect.mpg -vn -c copy -f vob detach.mpg

/extern/v853/external/eyesee-mpp/middleware/sun8iw21/media/videoIn/videoInputHw.c

/extern/v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY/libisp

/extern/v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY/libisp/isp.c

驱动目录
/extern/v853/lichee/linux-4.9/drivers/media/platform/sunxi-vin/modules/sensor/  

0x00,0xac,0x2d,0x87,0x54,0x05,0xff,0x01,0xc7,0x00,0x5a,0x50,0x00,0x00,0xb4,0x8c,0x28,0x0f,0x01,0x01

二进制查看文件 查看前300个字节
hexdump -C 21-20-00\(00373202\)_2.mp4 


确认是否能将g711封装成MP4
寻找封装264+g711的库
将原本的加密过程去掉
修改原始接口，传入pts
不止要封装264数据还要将sei sps pps封装进去
修改接口，适应设备的块内存方式
封装时需要修改nalu头为nalu的数据长度


video_common.c ZRT_Set_IspConfigBin 看效果文件配置

ffmpeg打印 Stream # dump_stream_format 分辨率 avcodec_string

要加快程序的写入速度，可以考虑以下几点：

使用缓冲区：将要写入的数据先存储在内存中的缓冲区中，然后一次性批量写入磁盘，而不是逐个数据写入。这样可以减少磁盘 I/O 操作，提高写入速度。

使用异步写入：在需要写入大量数据时，可以考虑使用异步写入方式，即在数据写入的同时，程序可以继续执行其他操作，不必等待写入完成。这样可以提高程序的整体效率。

优化文件格式：选择更适合写入速度的文件格式，比如使用二进制文件格式而不是文本文件格式，可以减少数据转换和处理的时间。

使用更快的存储设备：如果可能的话，将数据存储在更快速的存储设备上，比如固态硬盘（SSD）而不是传统的机械硬盘，可以显著提高写入速度。

考虑使用内存映射文件：对于需要频繁读写的大型文件，可以考虑使用内存映射文件，这样可以直接在内存中对文件进行操作，避免了频繁的磁盘 I/O 操作。


fopen有r、w、a等打开模式，t、b两个文件模式(文本或二进制)

用w、wb、w+b打开，无论如何都会清空原来文件中的数据，很麻烦，如果要多次读取修改文件，清空不是很理想的解决方案，
a、ab、a+b不会破坏原来数据，但只能添加到原来文件数据的后面，fseek基本失效，这样就修改不了原来的数据了，
r虽然不会破坏，但是修改不了，这个时候如果用r+b、r+就可以在保留文件原来内容的情况下设置文件指针后修改指定位置的内容了

神经网络是否只能学习同一类事物的特征，即通过多组同一类的输入和输出，学习特征


\assets\usr\bin\isp\f37p

assets/usr/bin/isp

删除当前目录小于1 byte的文件
find . -type f -size -1c -maxdepth 1 -exec rm {} \;


将一个数以网络字节序放在内存
static uint8_t *make_len(uint8_t *pbuf, int val)
{
    pbuf[0] = (uint8_t)((val >> 24) & 0xFF);
    pbuf[1] = (uint8_t)((val >> 16) & 0xFF);
    pbuf[2] = (uint8_t)((val >> 8) & 0xFF);
    pbuf[3] = (uint8_t)((val >> 0) & 0xFF);
    return pbuf;
}
将网络字节序数读出来
uint32_t bytesToUInt32(char *byte, int len) {
    if (len != 4)
    {
        return 0;
    }
    
    return (byte[0] << 24) | (byte[1] << 16) | (byte[2] << 8) | byte[3];
}

uint32 x=0x12345678;
fwrite((char*)&x,4,1,fp);//将一个数以主机字节序写入文件
fwrite((char*)make_len(&x,4),4,1,fp);//将一个数以网络字节序写入文件

网络字节序就是一个值在代码里看起来是0x12345678 那么写入文件也是12345678，而主机字节序写入后则是78563412

source ./build/envsetup.sh
lunch
2+2 lunch v853s_perf1-tina 7
make menuconfig

尝试封装264+g711 ps
尝试封装264+g711 MP4
去除加密
为了时间戳统一重新打包音频
写入MP4时修改头00000001为nalu长度
通过sps计算分辨率
根据底层编码给的时间戳计算并重打时间戳
修改MP4库，将moov头提到前面
定时更新moov头减小断电重启造成的数据损失
使用缓存，减小io次数，优化磁盘io
修改创建200kb空文件的创建时机
修改MP4库，实现断电续写
修改seek机制
修改回放录像逻辑
修改分辨率更新

#include <iostream>
using namespace std;

#define MOV_TAG(a, b, c, d) (((a) << 24) | ((b) << 16) | ((c) << 8) | (d))
#define MOV_VIDEO	MOV_TAG('v', 'i', 'd', 'e') // ISO/IEC 14496-12:2015(E) 12.1 Video media (p169)
#define MOV_AUDIO	MOV_TAG('s', 'o', 'u', 'n')

int main()
{
	unsigned int a = MOV_AUDIO;
	unsigned int v = MOV_VIDEO;
	
	cout<<a<<" "<<v<<endl;
   return 0;
}


nginx-1.17.9使用增加了stream 模块用于一般的TCP 代理和负载均衡，ngx_stream_core_module 这个模块在1.90版本后将被启用。但是并不会默认安装，
    需要在编译时通过指定 --with-stream 参数来激活这个模块。
      
    1）配置Nginx编译文件参数

./configure --with-stream

    2）编译、安装，make && make install

make & make install
 
    3）配置nginx.conf文件

    stream {
     upstream kevin {
     server 192.168.10.10:8080; #这里配置成要访问的地址
     server 192.168.10.20:8081;
     server 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
     }
     server {
     listen 8081; #需要监听的端口
     proxy_timeout 20s;
     proxy_pass kevin;
     }
    }

      
    创建最高级别的stream（与http同一级别），定义一个upstream组 名称为kevin，由多个服务组成达到负载均衡 定义一个服务用来监听TCP连接（如：8081端口），
    并且把他们代理到一个upstream组的kevin中，配置负载均衡的方法和参数为每个server；配置些如：连接数、权重等等。
      
    首先创建一个server组，用来作为TCP负载均衡组。定义一个upstream块在stream上下文中，在这个块里面添加由server命令定义的server，指定他的IP地址和
    主机名（能够被解析成多地址的主机名)和端口号。下面的例子是建立一个被称之为kevin组，两个监听1395端口的server ，一个监听8080端口的server。
      
    upstream kevin {
     server 192.168.10.10:8080; #这里配置成要访问的地址
     server 192.168.10.20:8081;
     server 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
     }
      
      
    需要特别注意的是：
    你不能为每个server定义协议，因为这个stream命令建立TCP作为整个 server的协议了。
      
    配置反向代理使Nginx能够把TCP请求从一个客户端转发到负载均衡组中(如：kevin组)。在每个server配置块中 通过每个虚拟server的server的配置信息和在
    每个server中定义的监听端口（客户端需求的代理端口号，如我推流的的是kevin协议，则端口号为：8081）的配置信息和proxy_passs 命令把TCP通信发送到
    upstream的哪个server中去。下面我们将TCP通信发送到kevin 组中去。
      
     server {
     listen 8081; #需要监听的端口
     proxy_timeout 20s;
     proxy_pass kevin;
     }
      
    当然我们也可以采用单一的代理方式：
      
    server {
     listen 8081; #需要监听的端口
     proxy_timeout 20s;
     proxy_pass 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
    }
    ------------------------------------------------------------------
      
    4）改变负载均衡的方法：
    默认nginx是通过轮询算法来进行负载均衡的通信的。引导这个请求循环的到配置在upstream组中server端口上去。 因为他是默认的方法，这里没有轮询命令，
    只是简单的创建一个upstream配置组在这儿stream山下文中，而且在其中添加server。


    a）least-connected ：对于每个请求，nginx plus选择当前连接数最少的server来处理:

    upstream kevin {
     least_conn;
     server 192.168.10.10:8080; #这里配置成要访问的地址
     server 192.168.10.20:8081;
     server 192.168.10.30:8081; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
    }
    

    b）ip_hash ：客户机的IP地址用作散列键，用于确定应该为客户机的请求选择服务器组中的哪个服务器

    upstream myapp1 {
        ip_hash;
        server srv1.example.com;
        server srv2.example.com;
        server srv3.example.com;
    }
    注：这个least time均衡方法没有
    c）普通的hash算法：nginx plus选择这个server是通过user_defined 关键字，就是IP地址：$remote_addr;

    upstream kevin {
     hash $remote_addr consistent;
     server 192.168.10.10:8080 weight=5; #这里配置成要访问的地址
     server 192.168.10.20:8081 max_fails=2 fail_timeout=30s;
     server 192.168.10.30:8081 max_conns=3; #需要代理的端口，在这里我代理一一个kevin模块的接口8081
    }


两张图片，两张图里都是同一个字，但是两张图的尺寸不同，在计算机科学中如何验证两张图里的字是同一个?

在计算机科学中，验证两张图像中的字是否相同通常涉及以下步骤：

图像预处理：首先，需要对两张图像进行预处理，确保它们具有相同的尺寸、颜色空间和对比度。这可以通过调整大小、灰度化和标准化颜色等方法来实现。

特征提取：接下来，从每个图像中提取特征，以便进行比较。一种常见的方法是使用特征描述符（如SIFT、SURF或ORB）来识别图像中的关键点和描述符。这些描述符可以捕获图像的局部特征。

特征匹配：通过比较两幅图像中提取的特征，可以进行特征匹配。这可以通过使用诸如最近邻居（Nearest Neighbors）匹配或一致性检查等算法来实现。

相似度度量：一旦完成特征匹配，可以计算两幅图像之间的相似度分数。这可以通过计算匹配特征点之间的距离或使用一些相似性度量（如结构相似性指数）来实现。

阈值设定：最后，可以根据相似度分数设置一个阈值，以确定两幅图像中的字是否相同。如果相似度分数超过阈值，则可以确定这两个字是相同的。

这些步骤构成了一种基本的图像相似度比较流程，可以用来验证两张图像中的字是否相同。然而，需要注意的是，这些方法可能受到图像尺寸差异、旋转、扭曲等因素的影响，因此在实际应用中需要考虑这些因素。


device/config/chips/v853s/configs/perf1/linux/env-4.9.cfg SWITCH=2
root@mars-virtual-machine:/extern/v853/device/config/chips/v853s/configs/perf1/linux# svn st
M       env-4.9.cfg
M       env-8188.cfg
M       env-EC800E.cfg


        self.conv1 = torch.nn.Sequential(
            torch.nn.Conv2d(1, 10, kernel_size=5),
            torch.nn.ReLU(),
            torch.nn.MaxPool2d(kernel_size=2),
        )
        self.conv2 = torch.nn.Sequential(
            torch.nn.Conv2d(10, 20, kernel_size=5),
            torch.nn.ReLU(),
            torch.nn.MaxPool2d(kernel_size=2),
        )
        self.fc = torch.nn.Sequential(
            torch.nn.Linear(320, 50),
            torch.nn.Linear(50, 10),
        )

linear:
Linear(in_features=4, out_features=3, bias=True)
weight:
Parameter containing:
tensor([[ 0.1580,  0.1197,  0.0419, -0.1967],
        [ 0.3840, -0.4597,  0.2347, -0.3428],
        [-0.3149,  0.2016,  0.2841,  0.4568]], requires_grad=True)

除了使用反向传播算法来找到过滤矩阵（如在卷积神经网络中的过滤器或权重）的方法外，还有其他几种可以探索的方法。以下是一些备选方法：

进化算法：这类算法通过模拟自然选择的过程来优化问题的解。在神经网络中，可以用进化算法来优化网络结构和权重，包括过滤矩阵。这种方法不需要反向传播，而是通过随机变异和选择最佳表现的个体来进化出最优解。

遗传算法：作为进化算法的一种，遗传算法使用交叉和变异操作来生成新的候选解，并用一个适应性函数来评价每个解的质量。这可以用于直接优化网络的权重，包括过滤矩阵。

模拟退火：这是一种概率型优化算法，灵感来源于物理中的退火过程。通过逐渐降低系统温度，模拟退火帮助找到全局最优解，减少陷入局部最优的可能。这种方法可以用于优化神经网络的权重。

粒子群优化（PSO）：这种方法通过模拟鸟群或鱼群的社会行为来优化问题。每个粒子代表一个解，通过跟踪个体和群体的最佳解来更新自己的位置和速度。这种方法同样适用于优化网络权重。

梯度自由优化：在某些情况下，可能需要在没有梯度信息的情况下优化权重，尤其是当损失函数不可导时。例如，使用Nelder-Mead单纯形方法等。

贝叶斯优化：这是一种基于概率模型的全局优化策略，常用于优化计算成本高昂的问题。通过建立目标函数的概率模型，贝叶斯优化可以有效地找到最优解。

强化学习：尽管通常用于不同的应用场景，但理论上可以通过设计一种环境和奖励机制，使用强化学习来优化神经网络的权重。
########################################

判断两个数据是否相似，可以使用上述提到的几种方法中的某些方法，尤其是那些用于特征提取和数据降维的方法。以下是几种适用于相似性判断的方法：

主成分分析（PCA）： 通过PCA，可以将两个数据集转换到相同的低维空间中，然后比较它们在这个空间中的距离或相似性。如果两个数据集在PCA变换后的主成分得分（或者说，低维表示）接近，那么可以认为它们在某种程度上是相似的。

自动编码器（Autoencoder）： 自动编码器同样可以用于提取数据的低维特征表示。如果两个数据点通过同一个训练好的自动编码器得到的编码（低维表示）相似，那么这两个数据点也可以被认为是相似的。这种方法在处理非线性数据关系时尤为有效。

奇异值分解（SVD）： 通过SVD也能得到数据的低维表示。通过比较两个数据矩阵的奇异值分解结果，可以估计它们的相似性。相似的数据将在奇异值和对应的奇异向量上表现出相似性。
########################################

概念和概念之间通过一个隐藏层连接，隐藏层需要建立一个索引系统，对于不同的语境，触发不同的隐藏节点

首先先建立语境，语境就是第一直觉，可以是对一系列的输入进行一个md5的过程，有了第一直觉，再通过第一直觉将信息进行分类识别

有一种神经网络模型叫做混合专家模型（Mixture of Experts），它可以根据输入的特征选择不同的隐藏层结构。具体来说，混合专家模型由多个专家网络组成，每个专家网络可以有不同的架构和参数。此外，还有一个称为门控网络（Gating Network）的部分，它根据输入特征来决定每个专家网络的权重，也就是说，它会根据输入的特征来选择最合适的专家网络或组合。


import torch

# 创建一个示例二维张量
tensor = torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])

# 沿维度0计算均值
mean_dim0 = torch.mean(tensor, dim=0)
print("Mean along dimension 0:", mean_dim0)

# 沿维度1计算均值
mean_dim1 = torch.mean(tensor, dim=1)
print("Mean along dimension 1:", mean_dim1)

# 沿维度0计算中位数
median_dim0 = torch.median(tensor, dim=0).values
print("Median along dimension 0:", median_dim0)

# 沿维度1计算中位数
median_dim1 = torch.median(tensor, dim=1).values
print("Median along dimension 1:", median_dim1)

PhoenixCard.exe

环境参数更新需要用量产卡刷才能更新

-Dxprint\(...\)#

重启标志
]:application(V


40:6A:8E:FF:38:0F
6d428d1d72f3c9c0b79b118105616dcc

fw_setenv mac 40:6A:8E:FF:38:0F
fw_setenv mac_sign 6d428d1d72f3c9c0b79b118105616dcc

小蛋
fw_setenv mac 40:6A:8E:FF:38:A5
fw_setenv mac_sign 37f94333bad1bb0a5fb4f2ea97d322a7

开机脚本
/home/mars/workspace/code/qzsdk/branch/threelens_switch/pack_threelens_switch/assets/etc/init.d/run_16M.sh

如果你想在 D:\Documents 目录下搜索，你应该这样输入：

"D:\Documents"

如果你想进一步搜索该目录下的特定文件或文件夹，可以在路径后添加搜索关键词。例如，搜索所有的 PDF 文件，可以这样输入：
"D:\Documents" *.pdf

或者，如果你想在该目录下只搜索文件夹，可以结合之前的 folder: 语法：

"D:\Documents" folder:

写驱动寄存器
cd /sys/devices/f37p_mipi #进入f37p_mipi驱动目录
echo 1 > read_flag #1读 0写
echo 00220000 > cci_client #地址0x22
cat read_value #获取值

echo 0 > read_flag #1读 0写
echo 00120030 > cci_client #往地址0x22写入0x30
cat read_value

cd /sys/devices/f37p_dvp;echo 0 > read_flag;echo 000c0001 > cci_client #walking1测试模式

if (!run_flag[i])
		{
			new_degree[i] = curr_degree[i];
		}
		else
		{
			new_degree[i] = curr_degree[i] + diff_curdegree*0.9;//并不直接转向目标点，只往那个方向转一部分，消除震荡
		}


型号 普维方案定义表

svn checkout https://192.168.10.195:448/svn/Qz-IPC/trunk/tina-v853 ./tina-v853

/tina-v853/external/eyesee-mpp/middleware/sun8iw21/media/LIBRARY  编码库目录

v851se_vc2 ## p5 ##v851se 2+1 
v851s3_vc  ## q1 ##v851s3 2+1 全时变焦2+1
v851s3_vc2  ## q3 ##v851s3 2+1 全时变焦2+1
v851s3_perf2 ## q2 ##v851s3 1+2
v851s3_perf1 ## q4 ##v851s3 2+2
v851se_perf1_switch ## p1 ##851se 1+2
v851se_perf1 ##851se 1+1
v853s_perf1 ## p3 ##v853s 2+1 三目
主线版本    ##    ##Q851SE 1+1 


白色的拼接相机就用v851se_perf1 ##851se 1+1 做固件

[2024/5/23 13:36:13] /usr/bin/check_stream.sh
[2024/5/23 13:36:13] =======check video node =========
[2024/5/23 13:36:13] video0   video10  video13  video2   video5   video8
[2024/5/23 13:36:13] video1   video12  video14  video4   video6   video9
[2024/5/23 13:36:13] =======check sensor mipi clk=========
[2024/5/23 13:36:13] mipi0 sensor clk : OK, clk_mode: Continuous Mode
[2024/5/23 13:36:13] cannot connect to the server
[2024/5/23 13:36:13] mipi1 sensor clk : OK, clk_mode: Continuous Mode
[2024/5/23 13:36:13] =======check mipi d0 trnds=========
[2024/5/23 13:36:13] mipi0-d0 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] mipi0-d1 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] mipi1-d0 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] mipi0-d1 trnds: ok (not TRNDS)
[2024/5/23 13:36:13] =======check mipi int erro=========
[2024/5/23 13:36:13] mipi0:
[2024/5/23 13:36:13] not erro
[2024/5/23 13:36:13] mipi1:
[2024/5/23 13:36:13] not erro
[2024/5/23 13:36:13] =======check dvp polarity=========
[2024/5/23 13:36:13] DVP_CLK_POL: active in falling edge
[2024/5/23 13:36:13] DVP_HERF_POL: positive
[2024/5/23 13:36:13] DVP_VREF_POL: negative
[2024/5/23 13:36:13] =======check dvp pclk cnt=========
[2024/5/23 13:36:13] DVP PCLK CNT: OK
[2024/5/23 13:36:13] =======check sensor mipi width & height=========
[2024/5/23 13:36:13] mipi0=> width:1920 , height:1080
[2024/5/23 13:36:13] mipi1=> width:1920 , height:1080
[2024/5/23 13:36:13] dvp=> width:1920 , height:1080
[2024/5/23 13:36:13] =======check csi mclk=========
[2024/5/23 13:36:13] csi0_mclk : NO
[2024/5/23 13:36:13] csi0_mclk_fre: 24000000
[2024/5/23 13:36:13] csi1_mclk : NO
[2024/5/23 13:36:13] csi1_mclk_fre: 24000000
[2024/5/23 13:36:13] csi2_mclk : NO
[2024/5/23 13:36:13] csi2_mclk_fre: 24000000
[2024/5/23 13:36:13] =======show vi pipe line =========
[2024/5/23 13:36:13] f37p_mipi => mipi0 => csi0 => tdm_rx0 => isp0 => vipp0
[2024/5/23 13:36:13] f37p_mipi_2 => mipi1 => csi1 => tdm_rx1 => isp1 => vipp1
[2024/5/23 13:36:13] f37p_dvp => csi2 => tdm_rx2 => isp2 => vipp2
[2024/5/23 13:36:13] =======check vi ch stream =========
[2024/5/23 13:36:15] vi stream is ok
[2024/5/23 13:36:15] =======check sensor i2c sda status=========
[2024/5/23 13:36:15] f37p_mipi i2c-0 SDA_STATUS: High, ok
[2024/5/23 13:36:15] f37p_mipi_2 i2c-1 SDA_STATUS: High, ok
[2024/5/23 13:36:15] f37p_dvp i2c-4 SDA_STATUS: High, ok
[2024/5/23 13:36:15] ==========END============


./i2cdetect -l        //用i2cdetect检测有几组i2c总线在系统上
./i2cdetect -r -y 1    //用i2cdetect检测挂载在i2c1总线上器件 
./i2cdump -f -y 1 0x49      //用i2cdump查看器件所有寄存器的值
用i2cset设置单个寄存器值，用i2cget读取单个寄存器值，可以在初期调试时发挥很大作用，一旦有预期的现象出现，就可以用i2cdump读出整个寄存器的值，然后固化到代码中。
./i2cset -f -y 1 0x20 0x77 0x3f （设置i2c-1上0x20器件的0x77寄存器值为0x3f）
./i2cget -f -y 1 0x20 0x77     （读取i2c-1上0x20器件的0x77寄存器值）

i2ctransfer -y 0 w1@0x42 0x00 r8 #读取总线0 设备0x42 地址0x00后8个字节


写一个shell脚本，用i2cset 将总线n上的m器件的u组数据写入寄存器，u组数据中包括地址v1 v2 ... vu，值w1 w2 ... wu
用python opencv写一个程序，主线程是一个固定窗口，还有一个子线程，窗口是一个绘制图片的窗口，窗口的生命周期就是程序的生命周期，线程从一个队列里读取数据，数据是一张图片，只要读到数据就重绘窗口内容，即清空窗口然后在窗口中绘制读到的图片

./set.sh 4 0x44 data.txt 
./set.sh 4 0x44 init_data.txt 
./get.sh 4 0x44 data.txt 

t5 ng rewrite reg
t6 ng log
t7 log 
t8 ng  log rewrite reg
t9 =t6
t10 =t8


t12 ng rewrite reg
t13 ng 没有rewrite reg

t15 没有ng 有日志打印 没有rewrite reg
t16 ng 有日志打印 没有rewrite reg

t18 ng + daemon_app 日志
t19 no ng + daemon_app 日志
t20 =t18
t21 =t19

t22 ng + daemon_app 日志 额外写

t23 ng + 记录uboot

t6 nodog + ng+ daemon_app 日志
t7 nodog + no ng+ daemon_app 日志
t9 nodog + ng 4路dma搬运 + daemon_app 日志

M       device/config/chips/v853s/configs/perf2/board.dts
M       device/config/chips/v853s/configs/perf2/linux/config-4.9
M       lichee/linux-4.9/drivers/media/platform/sunxi-vin/modules/sensor/f37p_dvp_gun.c


13606800301
Lixun1973

rm -rf /media/2024* /media/coredum* /media/1970* /media/*.alaw /media/*_*.mp4

umount /mnt/extsd
mount --bind /media/extsd /mnt/extsd
cp -r /tmp/nfs_share/extsd/ /media/extsd/
/mnt/extsd/demo_rtsp -path /mnt/extsd/venc_0.conf &

/media/op_reg.sh
/media/rw_cfg.sh

killall demo_rtsp
killall demo_rtsp_rec


删除size为0的(乱码)文件
find . -type f -size 0 -exec rm -f {} \;

echo -e "\033[0m"

用fuse挂载 
/usr/bin/allwin_fuse /media/ 
卸载
umount /media

mkfs.vfat -F 32 /dev/mmcblk0 #给存储设备mmcblk0制作FAT32文件系统
mount /dev/mmcblk0 /media  #把设备mmcblk0挂载到 /media

umount /media
mount /dev/mmcblk0 /media
mount /dev/mmcblk0 /mnt/extsd

umount /media;mount /dev/mmcblk0 /media;mount /dev/mmcblk0 /mnt/extsd;rm /mnt/extsd/*.raw;cp /media/gbl_rootfs.bint8 /media/gbl_rootfs.bin;/mnt/extsd/start.sh 

setenv SWITCH 2
saveenv 

svn commit -m "Your commit message here"

mac_sign=8357b50e384a6612afb4cb7dae2c6f0b
mac=40:6A:8E:FF:37:F1

fw_setenv mac 40:6A:8E:FF:37:F1
fw_setenv mac_sign 8357b50e384a6612afb4cb7dae2c6f0b

========================================
=======linux终端将16进制转成10进制=======
hex_values=(0x00 0xac 0x2d 0x87 0x54 0x05 0xff 0x01 0xc7 0x00 0x5a 0x50 0x00 0x00 0xb4 0x8c 0x28 0x0f 0x01 0x01)

for hex in "${hex_values[@]}"; do
    printf "%d " "$((hex))"
done
echo
========================================

在Linux终端中，可以使用sed命令来将逗号替换为空格。以下是具体的命令：
echo "0x00,0xac,0x2d,0x87,0x54,0x05,0xff,0x01,0xc7,0x00,0x5a,0x50,0x00,0x00,0xb4,0x8c,0x28,0x0f,0x01,0x01" | sed 's/,/ /g'


U-Boot（Universal Boot Loader）是一个广泛使用的开源引导程序，主要用于嵌入式系统中。它的主要作用是初始化硬件，加载操作系统内核，并将控制权交给内核。U-Boot 支持多种架构，包括ARM、PowerPC、x86、MIPS等。

U-Boot的主要功能
硬件初始化：在系统启动时，U-Boot负责初始化各种硬件设备，如内存控制器、串口、网卡、存储设备等。

引导操作系统：U-Boot可以从各种存储设备（如NAND、NOR、SD卡、eMMC、网络等）加载操作系统内核，并将控制权交给内核。

命令行接口：U-Boot提供一个交互式的命令行接口，允许用户执行各种命令来检查和修改系统配置，进行调试，或者手动加载内核。

设备树支持：U-Boot支持设备树（Device Tree），用于描述硬件布局和配置信息。

网络引导：U-Boot支持通过TFTP、NFS等网络协议引导操作系统，这对于开发和调试非常有用。

U-Boot的启动流程
ROM代码执行：在大多数嵌入式系统中，电源打开后，处理器首先执行ROM中的代码。这段代码通常是由硬件制造商提供的，它会初始化一些基本的硬件设置，并加载U-Boot到内存中。

U-Boot的第一阶段（SPL）：有些系统会使用一个小的初始引导程序（Secondary Program Loader，SPL），这是U-Boot的一部分，负责进一步初始化硬件并加载主U-Boot映像。

U-Boot的第二阶段：主U-Boot映像被加载到内存中并开始执行。此时，U-Boot会继续初始化更多的硬件设备，并准备好系统环境。

引导操作系统：U-Boot根据配置或用户命令加载操作系统内核，并将控制权交给内核，从而启动操作系统。

//间隔打印日志
#define printd(dt,fmt, ...)\
{\
	static uint64_t last_tm = 0;\
    uint64_t tm_ms = 0;\
	timestamp_ms_v3(&tm_ms);\
	if(tm_ms-last_tm>dt*1000)\
	{\
		last_tm=tm_ms;\
		ZRT_LOG_INFO(fmt "\n",##__VA_ARGS__);\
	}\
}

#include<stdio.h>

#define xprint \
{\
	static int val = 0;\
    val++;\
    printf("%d\n",val);\
}

void func()
{
    xprint
    xprint
    xprint
}
void main()
{
    func();
}
===================================================================================================

rtsp是基于tcp还是udp?

RTSP（Real-Time Streaming Protocol）是一种用于控制流媒体服务器的网络协议。它本身并不传输媒体数据，而是用于建立和控制媒体流会话。RTSP可以与多种传输层协议结合使用，包括TCP和UDP。

RTSP控制信令
RTSP的控制信令通常使用TCP进行传输。这是因为TCP提供了可靠的传输服务，确保控制命令能够准确无误地到达目的地。RTSP控制信令使用TCP的默认端口是554。

媒体流传输
虽然RTSP本身的控制信令通常使用TCP，但实际的媒体数据（音频和视频流）可以通过以下方式传输：

RTP over UDP: 这是最常见的方式，RTP（Real-time Transport Protocol）用于传输媒体数据，而RTCP（RTP Control Protocol）用于监控传输统计和质量。UDP的低延迟特性使其非常适合实时流媒体传输。

RTP over TCP: 在某些网络环境中（如防火墙阻碍UDP流量的情况下），RTP流可以通过TCP传输。虽然TCP的可靠性可以确保数据包按顺序到达，但其高延迟和重传机制可能会影响流媒体的实时性。

RTP over RTSP (RTSP Interleaved Mode): RTP流可以嵌入在RTSP控制信令的TCP连接中传输，这种方式称为RTSP交错模式（interleaved mode）。这在防火墙和NAT设备阻止独立RTP/UDP流的情况下特别有用。

配置示例
在使用RTSP时，具体的传输方式通常可以通过RTSP SETUP命令中的传输参数进行配置。例如：

使用RTP over UDP：

SETUP rtsp://example.com/media.mp4 RTSP/1.0
CSeq: 4
Transport: RTP/AVP;unicast;client_port=8000-8001

使用RTP over TCP：

SETUP rtsp://example.com/media.mp4 RTSP/1.0
CSeq: 4
Transport: RTP/AVP/TCP;unicast;interleaved=0-1

总结
RTSP控制信令：通常基于TCP传输。
媒体数据传输：可以使用RTP over UDP、RTP over TCP或RTP over RTSP（交错模式）进行传输。
这种灵活性使RTSP能够适应各种网络环境和应用需求。

===================================================================================================
https://cloud.tencent.com/developer/article/2020387
===================================================================================================

V7.03.27.p4.t4就是最终对离线问题做了优化的


/usr/bin/check_stream.sh > /media/stream1.txt
/usr/bin/check_stream.sh > /media/stream2.txt
/usr/bin/check_stream.sh > /media/stream3.txt
/usr/bin/check_stream.sh > /media/stream4.txt
/usr/bin/check_stream.sh > /media/stream5.txt

触发告警函数
m_alarmPushCb(eTrackType, enable_push, suppress_alarm);

===================================================================================================
给出一个键盘驱动程序，并结合这个程序说明一下他们的合作机制

编写一个完整的键盘驱动程序涉及许多复杂的细节。在这里，我将提供一个简化的示例，展示如何编写一个基本的键盘驱动程序，并结合这个程序说明操作系统和驱动程序的合作机制。

示例：一个简化的键盘驱动程序
以下示例是一个简单的Linux内核模块，它处理键盘输入。请注意，这只是一个非常简化的版本，实际的键盘驱动程序要复杂得多。

驱动程序代码（简化版）
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>
#include <linux/input.h>

#define KEYBOARD_IRQ 1

static struct input_dev *keyboard_dev;

irqreturn_t keyboard_interrupt(int irq, void *dev_id) {
    printk(KERN_INFO "Keyboard interrupt received.\n");
    // 在这里处理键盘输入，例如读取键码
    return IRQ_HANDLED;
}

static int __init keyboard_init(void) {
    int result;

    // 注册输入设备
    keyboard_dev = input_allocate_device();
    if (!keyboard_dev) {
        printk(KERN_ERR "Unable to allocate input device.\n");
        return -ENOMEM;
    }

    keyboard_dev->name = "Simple Keyboard Driver";
    keyboard_dev->phys = "keyboard/input0";
    keyboard_dev->id.bustype = BUS_I8042;
    keyboard_dev->id.vendor = 0x0001;
    keyboard_dev->id.product = 0x0001;
    keyboard_dev->id.version = 0x0100;

    // 注册输入设备
    result = input_register_device(keyboard_dev);
    if (result) {
        printk(KERN_ERR "Unable to register input device.\n");
        input_free_device(keyboard_dev);
        return result;
    }

    // 请求中断
    result = request_irq(KEYBOARD_IRQ, keyboard_interrupt, IRQF_SHARED, "simple_keyboard", (void *)(keyboard_interrupt));
    if (result) {
        printk(KERN_ERR "Unable to request IRQ.\n");
        input_unregister_device(keyboard_dev);
        return result;
    }

    printk(KERN_INFO "Simple keyboard driver initialized.\n");
    return 0;
}

static void __exit keyboard_exit(void) {
    free_irq(KEYBOARD_IRQ, (void *)(keyboard_interrupt));
    input_unregister_device(keyboard_dev);
    printk(KERN_INFO "Simple keyboard driver exited.\n");
}

module_init(keyboard_init);
module_exit(keyboard_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Simple Keyboard Driver");

合作机制说明
1. 驱动程序的加载和初始化
当内核模块加载时，module_init(keyboard_init)函数会被调用。在这个函数中，驱动程序执行以下操作：

分配并初始化一个输入设备结构（input_allocate_device）。
注册输入设备（input_register_device），使操作系统知道这个设备的存在。
请求获取键盘中断（request_irq），并将中断处理函数（keyboard_interrupt）与键盘中断向量关联起来。
2. 键盘中断处理
当键盘生成中断时（例如按下或释放一个键），硬件会向CPU发送一个中断信号。操作系统的中断处理程序会捕获这个中断，并调用注册的中断处理函数keyboard_interrupt。在这个简化的示例中，中断处理函数只是打印了一条日志信息，但在实际的驱动程序中，它会读取键盘控制器的寄存器以确定哪个键被按下或释放，并将这个信息传递给操作系统。

3. 数据传递到用户空间
在实际的键盘驱动程序中，中断处理函数会将键盘事件（按键和释放事件）传递给输入子系统。输入子系统会将这些事件传递给用户空间的应用程序。例如，当按下一个键时，驱动程序会生成一个输入事件，操作系统会将这个事件传递给正在运行的应用程序（如终端、文本编辑器等）。

4. 驱动程序的卸载
当内核模块被卸载时，module_exit(keyboard_exit)函数会被调用。在这个函数中，驱动程序执行以下操作：

释放键盘中断（free_irq）。
注销输入设备（input_unregister_device），使操作系统知道这个设备不再可用。
总结
操作系统和键盘驱动程序通过中断和事件机制进行合作。操作系统管理中断向量和输入子系统，而驱动程序处理具体的硬件操作（例如读取键码）。当键盘生成中断时，操作系统会调用驱动程序的中断处理函数，驱动程序处理键盘事件并将其传递给操作系统的输入子系统。最终，输入子系统将这些事件传递给用户空间的应用程序，从而实现键盘输入的处理。

操作系统怎么知道哪个设备对应哪个驱动程序

操作系统如何知道哪个设备对应哪个驱动程序是一个复杂的过程，涉及到硬件和软件之间的多层次交互。以下是操作系统识别和匹配设备与驱动程序的主要机制和步骤：

1. 设备描述和识别
每个硬件设备都有一些唯一的标识符，用于描述其类型、制造商、型号等信息。这些标识符通常包括：

设备ID：如PCI设备的Vendor ID和Device ID。
类代码：表示设备类型，如网络设备、存储设备等。
子系统ID：进一步细分设备的类型和功能。
2. 总线扫描和设备发现
操作系统在启动时，会扫描各种总线（如PCI、USB、I2C）以发现连接到系统的所有设备。每种总线都有其特定的扫描机制：

PCI总线：操作系统会读取PCI配置空间，获取每个PCI设备的Vendor ID和Device ID。
USB总线：操作系统会通过USB协议与每个USB设备通信，获取其设备描述符。
3. 设备树和设备描述文件
一些操作系统使用设备树（Device Tree）或设备描述文件（如ACPI表）来描述硬件设备和它们的属性。操作系统会解析这些描述文件，以了解系统中的硬件布局和属性。

4. 驱动程序注册
驱动程序在加载时会向操作系统注册自己，并提供可以处理的设备类型和标识符。例如，一个PCI网卡驱动程序可能会注册其支持的Vendor ID和Device ID列表。驱动程序的注册通常通过如下方式进行：

PCI驱动程序：通过pci_register_driver函数注册。
USB驱动程序：通过usb_register函数注册。
平台驱动程序：通过platform_driver_register函数注册。
5. 设备与驱动程序匹配
操作系统使用一个设备驱动模型来管理设备和驱动程序之间的匹配过程。这个模型通常包括以下步骤：

设备发现：操作系统扫描总线，发现设备，并创建设备对象。
驱动程序注册：驱动程序加载并注册自己，提供可以处理的设备标识符。
匹配过程：操作系统根据设备标识符和驱动程序注册信息进行匹配。如果发现一个设备的标识符与某个驱动程序的支持列表匹配，操作系统将该驱动程序绑定到设备上。
6. 设备初始化
一旦设备和驱动程序匹配成功，操作系统会调用驱动程序的初始化函数，完成设备的初始化。驱动程序会执行以下操作：

配置设备寄存器。
分配必要的资源（如内存、I/O端口）。
注册设备节点，使用户空间可以访问该设备。
示例：PCI设备与驱动程序匹配
以Linux操作系统中的PCI设备为例：

设备扫描
操作系统扫描PCI总线，发现一个新的PCI设备，读取其Vendor ID和Device ID。

驱动程序注册
static const struct pci_device_id my_pci_ids[] = {
    { PCI_DEVICE(PCI_VENDOR_ID_MYDEVICE, PCI_DEVICE_ID_MYDEVICE) },
    { 0, }
};

static struct pci_driver my_pci_driver = {
    .name = "my_pci_driver",
    .id_table = my_pci_ids,
    .probe = my_pci_probe,
    .remove = my_pci_remove,
};

pci_register_driver(&my_pci_driver);

匹配过程
操作系统在发现PCI设备时，会检查所有已经注册的PCI驱动程序。根据设备的Vendor ID和Device ID，找到匹配的驱动程序my_pci_driver。

设备初始化
操作系统调用my_pci_driver的probe函数，驱动程序在该函数中初始化设备：

static int my_pci_probe(struct pci_dev *dev, const struct pci_device_id *id) {
    // 初始化设备
    return 0;
}

总结
操作系统通过设备标识符（如Vendor ID和Device ID）、总线扫描、设备树和设备描述文件等机制，发现并识别系统中的硬件设备。驱动程序通过注册自己可以处理的设备类型和标识符，告诉操作系统自己能处理哪些设备。操作系统通过匹配设备标识符和驱动程序注册信息，确定哪个驱动程序处理哪个设备。最终，操作系统调用驱动程序的初始化函数，完成设备的初始化和配置。

前面那个键盘驱动程序里，哪些函数是内核接口？

在前面提供的简化键盘驱动程序示例中，许多函数和接口都是内核提供的接口，用于管理设备、请求中断、分配资源等。以下是这些内核接口的详细解释：

1. input_allocate_device
keyboard_dev = input_allocate_device();

作用: 分配并初始化一个input_dev结构体，用于表示一个输入设备。
内核接口: 是的，这是一个内核接口，位于Linux内核输入子系统中。
2. input_register_device
result = input_register_device(keyboard_dev);

作用: 注册一个输入设备，使其可被输入子系统识别和使用。
内核接口: 是的，这是一个内核接口。
3. input_free_device
input_free_device(keyboard_dev);

作用: 释放通过input_allocate_device分配的输入设备结构。
内核接口: 是的，这是一个内核接口。
4. request_irq
result = request_irq(KEYBOARD_IRQ, keyboard_interrupt, IRQF_SHARED, "simple_keyboard", (void *)(keyboard_interrupt));

作用: 请求一个中断，并将其与中断处理函数关联起来。
内核接口: 是的，这是一个内核接口，用于请求硬件中断。
5. free_irq
free_irq(KEYBOARD_IRQ, (void *)(keyboard_interrupt));

作用: 释放一个先前请求的中断。
内核接口: 是的，这是一个内核接口，用于释放硬件中断。
6. module_init
module_init(keyboard_init);

作用: 指定模块初始化函数，在模块加载时调用。
内核接口: 是的，这是一个内核接口，用于模块初始化。
7. module_exit
module_exit(keyboard_exit);

作用: 指定模块清理函数，在模块卸载时调用。
内核接口: 是的，这是一个内核接口，用于模块清理。
8. printk
printk(KERN_INFO "Simple keyboard driver initialized.\n");

作用: 向内核日志缓冲区输出信息。
内核接口: 是的，这是一个内核接口，用于内核日志输出。
9. MODULE_LICENSE
MODULE_LICENSE("GPL");

作用: 指定模块的许可证类型。
内核接口: 是的，这是一个内核宏，用于声明模块的许可证。
10. MODULE_AUTHOR
MODULE_AUTHOR("An Example Author");

作用: 指定模块的作者信息。
内核接口: 是的，这是一个内核宏，用于声明模块的作者。
11. MODULE_DESCRIPTION
MODULE_DESCRIPTION("A Simple Keyboard Driver");

作用: 提供模块的描述信息。
内核接口: 是的，这是一个内核宏，用于声明模块的描述。
整理后的内核接口函数列表
input_allocate_device
input_register_device
input_free_device
request_irq
free_irq
module_init
module_exit
printk
MODULE_LICENSE
MODULE_AUTHOR
MODULE_DESCRIPTION
这些函数和宏是Linux内核提供的接口，允许驱动程序开发人员与内核和硬件进行交互。它们用于设备管理、中断处理、资源分配和模块管理等方面。

总结
在简化的键盘驱动程序示例中，多个内核接口函数和宏用于管理输入设备、请求和释放中断、输出内核日志以及模块的初始化和清理。这些内核接口使得驱动程序能够与操作系统的内核层紧密合作，从而实现对硬件设备的管理和控制。

一般来说，键盘发生按键事件后，这个keyboard_interrupt要做什么？

当键盘发生按键事件时，中断处理函数（keyboard_interrupt）需要执行一系列步骤来处理这个事件，确保按键信息能够正确地传递到应用程序。以下是一个典型的键盘中断处理过程中需要执行的主要任务：

1. 确认中断源
确保中断确实来自键盘设备。这通常通过读取特定的硬件寄存器来完成。
2. 读取按键扫描码
键盘控制器会在按键按下或松开时生成一个扫描码（scan code）。中断处理程序需要读取这个扫描码。
在PC兼容系统中，通常从I/O端口0x60读取扫描码（对于传统的PS/2键盘）。
3. 处理扫描码
处理扫描码以确定具体的按键事件。这包括区分按键按下和松开事件，以及处理特殊键（如Shift、Ctrl等）的状态。
4. 生成输入事件
将扫描码转换为键码（key code），并生成相应的输入事件。
这些事件通常包括按键按下（EV_KEY with value 1）和按键释放（EV_KEY with value 0）。
5. 把输入事件传递给输入子系统
使用内核输入子系统接口（如input_report_key）将生成的按键事件报告给输入子系统。
确保事件能够正确地传递到用户空间的应用程序。
6. 处理键盘LED状态（如Num Lock、Caps Lock等）
如果按键事件涉及到修改键盘LED状态，中断处理程序需要更新LED状态。
7. 清除中断请求
通知硬件中断已被处理，准备接收下一个中断请求。
示例代码：键盘中断处理函数
下面是一个更详细和实际的键盘中断处理函数示例代码，它展示了上述步骤的实现：

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/interrupt.h>
#include <linux/input.h>
#include <linux/io.h>

#define KEYBOARD_IRQ 1
#define KBD_DATA_REG 0x60
#define KBD_STATUS_REG 0x64

static struct input_dev *keyboard_dev;

irqreturn_t keyboard_interrupt(int irq, void *dev_id) {
    unsigned char scancode;
    int keycode;
    int keydown;

    // 读取扫描码
    scancode = inb(KBD_DATA_REG);

    // 处理扫描码，区分按下和释放事件
    keydown = !(scancode & 0x80);
    scancode = scancode & 0x7F;

    // 将扫描码转换为键码（这里假设有一个函数get_keycode实现转换）
    keycode = get_keycode(scancode);

    // 向输入子系统报告按键事件
    input_report_key(keyboard_dev, keycode, keydown);
    input_sync(keyboard_dev);

    return IRQ_HANDLED;
}

static int __init keyboard_init(void) {
    int result;

    // 注册输入设备
    keyboard_dev = input_allocate_device();
    if (!keyboard_dev) {
        printk(KERN_ERR "Unable to allocate input device.\n");
        return -ENOMEM;
    }

    keyboard_dev->name = "Simple Keyboard Driver";
    keyboard_dev->phys = "keyboard/input0";
    keyboard_dev->id.bustype = BUS_I8042;
    keyboard_dev->id.vendor = 0x0001;
    keyboard_dev->id.product = 0x0001;
    keyboard_dev->id.version = 0x0100;

    // 注册输入设备
    result = input_register_device(keyboard_dev);
    if (result) {
        printk(KERN_ERR "Unable to register input device.\n");
        input_free_device(keyboard_dev);
        return result;
    }

    // 请求中断
    result = request_irq(KEYBOARD_IRQ, keyboard_interrupt, IRQF_SHARED, "simple_keyboard", (void *)(keyboard_interrupt));
    if (result) {
        printk(KERN_ERR "Unable to request IRQ.\n");
        input_unregister_device(keyboard_dev);
        return result;
    }

    printk(KERN_INFO "Simple keyboard driver initialized.\n");
    return 0;
}

static void __exit keyboard_exit(void) {
    free_irq(KEYBOARD_IRQ, (void *)(keyboard_interrupt));
    input_unregister_device(keyboard_dev);
    printk(KERN_INFO "Simple keyboard driver exited.\n");
}

module_init(keyboard_init);
module_exit(keyboard_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Simple Keyboard Driver");

解释
确认中断源:

在这个示例中，假设中断已经正确地路由到键盘中断处理程序，因此没有显式地确认中断源。
读取按键扫描码:

scancode = inb(KBD_DATA_REG);

使用inb函数从I/O端口0x60读取扫描码。
处理扫描码:

keydown = !(scancode & 0x80);
scancode = scancode & 0x7F;

检查最高位以区分按键按下（keydown）和按键释放（keyup）。
去掉最高位得到实际的扫描码。
生成输入事件:

keycode = get_keycode(scancode);
input_report_key(keyboard_dev, keycode, keydown);
input_sync(keyboard_dev);

将扫描码转换为键码。
使用input_report_key函数向输入子系统报告按键事件。
使用input_sync函数同步事件。
处理键盘LED状态:

示例中没有处理键盘LED状态，但在实际驱动中可能需要。
清除中断请求:

示例中没有显式的清除中断请求，因为大多数硬件在读取扫描码后会自动清除中断。
总结
键盘中断处理程序的主要任务是读取按键扫描码、处理扫描码、生成输入事件并将其传递给输入子系统。这个过程确保了按键事件能够正确地从硬件传递到用户空间的应用程序。在实际驱动程序中，可能还需要处理键盘LED状态和其他特定硬件特性。

input_report_key(keyboard_dev, keycode, keydown); input_sync(keyboard_dev);这两个也是内核接口吗？

是的，input_report_key和input_sync都是Linux内核输入子系统提供的接口函数，用于驱动程序向输入子系统报告输入事件并同步这些事件。

input_report_key
void input_report_key(struct input_dev *dev, unsigned int code, int value);

作用: 报告一个键的状态变化事件。
dev: 输入设备结构体指针。
code: 键码（key code），表示具体的按键。
value: 按键状态，通常为1表示按下，0表示释放。
内核接口: 是的，这是一个内核接口函数，用于将按键事件报告给输入子系统。
input_sync
void input_sync(struct input_dev *dev);

作用: 同步报告的输入事件，确保事件能够被正确处理和传递。
dev: 输入设备结构体指针。
内核接口: 是的，这是一个内核接口函数，用于同步输入事件。
详细解释
input_report_key
当键盘中断处理程序检测到一个按键按下或释放事件时，它需要调用input_report_key函数来报告这个事件。这个函数会将按键事件存储在输入设备的事件队列中，等待进一步处理。

input_report_key(keyboard_dev, keycode, keydown);

keyboard_dev: 表示键盘设备。
keycode: 表示具体的按键（如'A'键、'Enter'键等）。
keydown: 表示按键状态（1表示按下，0表示释放）。
input_sync
在调用input_report_key报告按键事件后，驱动程序需要调用input_sync函数来同步这些事件。input_sync函数会通知输入子系统已经完成了事件的报告，输入子系统可以处理这些事件并将其传递给用户空间。

input_sync(keyboard_dev);

keyboard_dev: 表示键盘设备。
示例代码：结合input_report_key和input_sync
以下是一个示例，展示如何在键盘中断处理程序中使用input_report_key和input_sync来报告按键事件并同步：

irqreturn_t keyboard_interrupt(int irq, void *dev_id) {
    unsigned char scancode;
    int keycode;
    int keydown;

    // 读取扫描码
    scancode = inb(KBD_DATA_REG);

    // 处理扫描码，区分按下和释放事件
    keydown = !(scancode & 0x80);
    scancode = scancode & 0x7F;

    // 将扫描码转换为键码（这里假设有一个函数get_keycode实现转换）
    keycode = get_keycode(scancode);

    // 向输入子系统报告按键事件
    input_report_key(keyboard_dev, keycode, keydown);
    input_sync(keyboard_dev);

    return IRQ_HANDLED;
}

总结
**input_report_key和input_sync**都是Linux内核提供的接口函数，属于输入子系统的一部分。
**input_report_key**用于报告具体的按键事件（按下或释放）。
**input_sync**用于同步事件，确保输入子系统可以正确处理和传递这些事件。
这些内核接口函数使得驱动程序能够将硬件事件（如按键事件）报告给输入子系统，从而使用户空间的应用程序可以正确地接收到这些事件并做出相应的响应。


如果是用户程序主动发起的事件，比如打印，那么这个驱动是怎么响应这个事件的呢？

用户空间程序主动发起的事件（如打印任务）需要通过特定的接口与设备驱动程序进行通信。一般来说，这种通信通常通过以下几种方式实现：

设备文件（Device Files）
ioctl（输入输出控制）
sysfs文件系统
Netlink套接字
我们以一个打印任务的例子来详细说明如何通过设备文件和ioctl来实现用户空间程序与设备驱动程序的通信。

示例：打印任务
假设我们有一个打印机驱动程序，用户空间程序通过设备文件/dev/printer与打印机驱动程序通信。

用户空间程序
用户空间程序通过打开设备文件，向设备文件写数据，或通过ioctl发送控制命令来发起打印任务。

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>

#define PRINTER_IOCTL_PRINT _IOW('p', 1, struct print_data)

struct print_data {
    char *buffer;
    size_t length;
};

int main() {
    int fd = open("/dev/printer", O_RDWR);
    if (fd < 0) {
        perror("Failed to open printer device");
        return 1;
    }

    // 要打印的字符串
    const char *print_str = "Hello, Printer!";
    struct print_data pdata;
    pdata.buffer = (char *)print_str;
    pdata.length = strlen(print_str);

    // 通过ioctl发送打印命令
    if (ioctl(fd, PRINTER_IOCTL_PRINT, &pdata) < 0) {
        perror("Failed to send print command");
        close(fd);
        return 1;
    }

    close(fd);
    return 0;
}

内核驱动程序
内核驱动程序需要实现对设备文件的操作和ioctl命令的处理。

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "printer"
#define PRINTER_IOCTL_PRINT _IOW('p', 1, struct print_data)

struct print_data {
    char *buffer;
    size_t length;
};

static int device_open(struct inode *inode, struct file *file) {
    printk(KERN_INFO "Printer device opened\n");
    return 0;
}

static int device_release(struct inode *inode, struct file *file) {
    printk(KERN_INFO "Printer device closed\n");
    return 0;
}

static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    struct print_data pdata;
    char *kernel_buffer;

    switch (cmd) {
        case PRINTER_IOCTL_PRINT:
            if (copy_from_user(&pdata, (struct print_data *)arg, sizeof(struct print_data))) {
                return -EFAULT;
            }

            kernel_buffer = kmalloc(pdata.length, GFP_KERNEL);
            if (!kernel_buffer) {
                return -ENOMEM;
            }

            if (copy_from_user(kernel_buffer, pdata.buffer, pdata.length)) {
                kfree(kernel_buffer);
                return -EFAULT;
            }

            // 模拟打印操作
            printk(KERN_INFO "Printing: %s\n", kernel_buffer);

            kfree(kernel_buffer);
            break;

        default:
            return -EINVAL;
    }

    return 0;
}

static struct file_operations fops = {
    .open = device_open,
    .release = device_release,
    .unlocked_ioctl = device_ioctl,
};

static int __init printer_init(void) {
    int ret;

    ret = register_chrdev(0, DEVICE_NAME, &fops);
    if (ret < 0) {
        printk(KERN_ALERT "Failed to register character device\n");
        return ret;
    }

    printk(KERN_INFO "Printer driver initialized\n");
    return 0;
}

static void __exit printer_exit(void) {
    unregister_chrdev(0, DEVICE_NAME);
    printk(KERN_INFO "Printer driver exited\n");
}

module_init(printer_init);
module_exit(printer_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Simple Printer Driver");

解释
用户空间程序：

打开设备文件/dev/printer。
构造一个print_data结构体，包含要打印的字符串及其长度。
通过ioctl发送PRINTER_IOCTL_PRINT命令，将print_data结构体传递给驱动程序。
内核驱动程序：

实现设备文件的open、release和ioctl操作。
在ioctl操作中，处理PRINTER_IOCTL_PRINT命令：
从用户空间复制print_data结构体。
分配内核缓冲区并从用户空间复制要打印的数据。
模拟打印操作（通过printk输出到内核日志）。
释放内核缓冲区。
总结
用户空间程序通过设备文件和ioctl与内核驱动程序通信，实现主动发起的事件（如打印任务）。内核驱动程序通过实现相应的文件操作函数和ioctl处理函数，对用户空间程序的请求做出响应。这样，用户空间程序可以通过受控和安全的方式与内核驱动程序进行交互。

如果外设工作生成的数据并不是通用的，不能像keyboard_interrupt通过内核接口上报给子系统，是否就是通过设备文件缓存？

是的，如果外设生成的数据并不是通用的，不能像键盘那样通过内核接口上报给输入子系统，通常可以使用设备文件（device files）来处理这些数据。设备文件是用户空间程序与内核驱动程序之间通信的桥梁，适用于各种类型的设备，不论其生成的数据格式是否通用。

使用设备文件处理外设数据
通过设备文件，驱动程序可以将外设生成的数据存储在内核缓冲区中，用户空间程序则可以通过读取设备文件来获取这些数据。下面是一个示例，展示如何通过设备文件处理外设生成的非通用数据。

示例：传感器数据
假设我们有一个传感器设备，它生成的数据格式不是通用的。我们可以通过设备文件将这些数据传递给用户空间程序。

内核驱动程序
定义设备文件操作函数：

实现open、read、write、release等文件操作函数。
使用内核缓冲区存储传感器数据。
模拟传感器数据生成：

模拟传感器数据生成过程，并将数据存储到内核缓冲区。
实现设备文件的读操作：

用户空间程序通过读取设备文件来获取传感器数据。
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/slab.h>

#define DEVICE_NAME "sensor"
#define BUFFER_SIZE 1024

static int major_number;
static char *sensor_buffer;
static size_t buffer_pos;
static struct class *sensor_class = NULL;
static struct device *sensor_device = NULL;

static int device_open(struct inode *inode, struct file *file) {
    printk(KERN_INFO "Sensor device opened\n");
    return 0;
}

static int device_release(struct inode *inode, struct file *file) {
    printk(KERN_INFO "Sensor device closed\n");
    return 0;
}

static ssize_t device_read(struct file *file, char __user *user_buffer, size_t len, loff_t *offset) {
    ssize_t bytes_read;

    if (*offset >= buffer_pos) {
        return 0; // End of buffer
    }

    if (*offset + len > buffer_pos) {
        len = buffer_pos - *offset; // Adjust length to avoid reading beyond buffer
    }

    if (copy_to_user(user_buffer, sensor_buffer + *offset, len)) {
        return -EFAULT;
    }

    *offset += len;
    bytes_read = len;

    return bytes_read;
}

static struct file_operations fops = {
    .open = device_open,
    .release = device_release,
    .read = device_read,
};

static int __init sensor_init(void) {
    major_number = register_chrdev(0, DEVICE_NAME, &fops);
    if (major_number < 0) {
        printk(KERN_ALERT "Failed to register character device\n");
        return major_number;
    }

    sensor_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(sensor_class)) {
        unregister_chrdev(major_number, DEVICE_NAME);
        printk(KERN_ALERT "Failed to create device class\n");
        return PTR_ERR(sensor_class);
    }

    sensor_device = device_create(sensor_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
    if (IS_ERR(sensor_device)) {
        class_destroy(sensor_class);
        unregister_chrdev(major_number, DEVICE_NAME);
        printk(KERN_ALERT "Failed to create device\n");
        return PTR_ERR(sensor_device);
    }

    sensor_buffer = kmalloc(BUFFER_SIZE, GFP_KERNEL);
    if (!sensor_buffer) {
        device_destroy(sensor_class, MKDEV(major_number, 0));
        class_destroy(sensor_class);
        unregister_chrdev(major_number, DEVICE_NAME);
        printk(KERN_ALERT "Failed to allocate buffer\n");
        return -ENOMEM;
    }

    // 模拟传感器数据生成
    snprintf(sensor_buffer, BUFFER_SIZE, "Sensor Data: Temperature=25.5, Humidity=60%%");
    buffer_pos = strlen(sensor_buffer);

    printk(KERN_INFO "Sensor driver initialized\n");
    return 0;
}

static void __exit sensor_exit(void) {
    kfree(sensor_buffer);
    device_destroy(sensor_class, MKDEV(major_number, 0));
    class_destroy(sensor_class);
    unregister_chrdev(major_number, DEVICE_NAME);
    printk(KERN_INFO "Sensor driver exited\n");
}

module_init(sensor_init);
module_exit(sensor_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Simple Sensor Driver");

用户空间程序
用户空间程序通过读取设备文件来获取传感器数据。

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE 1024

int main() {
    int fd;
    char buffer[BUFFER_SIZE];
    ssize_t bytes_read;

    fd = open("/dev/sensor", O_RDONLY);
    if (fd < 0) {
        perror("Failed to open sensor device");
        return 1;
    }

    bytes_read = read(fd, buffer, BUFFER_SIZE - 1);
    if (bytes_read < 0) {
        perror("Failed to read from sensor device");
        close(fd);
        return 1;
    }

    buffer[bytes_read] = '\0';
    printf("Sensor Data: %s\n", buffer);

    close(fd);
    return 0;
}

解释
内核驱动程序：

初始化：在模块初始化函数中，注册字符设备并创建设备文件，分配内核缓冲区并模拟传感器数据生成。
文件操作：实现open、release和read操作函数，处理设备文件的打开、关闭和读取操作。
数据读取：在device_read函数中，从内核缓冲区读取传感器数据并复制到用户空间缓冲区。
用户空间程序：

打开设备文件：使用open系统调用打开设备文件/dev/sensor。
读取数据：使用read系统调用从设备文件读取传感器数据并打印到标准输出。
总结
当外设生成的数据不是通用的，不能通过标准的内核接口上报给子系统时，可以通过设备文件来缓存和传递这些数据。内核驱动程序可以将数据存储在内核缓冲区中，用户空间程序通过读取设备文件来获取这些数据。这种方式提供了一种灵活的机制，适用于各种自定义数据格式和设备。

除了设备文件缓存还有别的方式传递或者存储吗？

除了设备文件缓存之外，还有其他几种方法可以在用户空间程序和内核驱动程序之间传递或存储数据。这些方法包括：

1. ioctl（输入输出控制）
ioctl（输入输出控制）是一个通用的系统调用，允许用户空间程序向设备驱动程序发送控制命令和数据。它非常灵活，可以用于传递各种类型的数据。

示例
用户空间程序：

#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string.h>

#define DEVICE_FILE "/dev/mydevice"
#define IOCTL_CMD _IOW('m', 1, char*)

int main() {
    int fd = open(DEVICE_FILE, O_RDWR);
    if (fd < 0) {
        perror("Failed to open device file");
        return 1;
    }

    char data[] = "Hello, kernel!";
    if (ioctl(fd, IOCTL_CMD, data) < 0) {
        perror("Failed to send ioctl command");
        close(fd);
        return 1;
    }

    close(fd);
    return 0;
}

内核驱动程序：

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "mydevice"
#define IOCTL_CMD _IOW('m', 1, char*)

static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    char buffer[128];

    switch (cmd) {
        case IOCTL_CMD:
            if (copy_from_user(buffer, (char __user *)arg, sizeof(buffer))) {
                return -EFAULT;
            }
            printk(KERN_INFO "Received from user: %s\n", buffer);
            break;
        default:
            return -EINVAL;
    }

    return 0;
}

static struct file_operations fops = {
    .unlocked_ioctl = device_ioctl,
};

static int __init mydevice_init(void) {
    int ret = register_chrdev(0, DEVICE_NAME, &fops);
    if (ret < 0) {
        printk(KERN_ALERT "Failed to register character device\n");
        return ret;
    }
    printk(KERN_INFO "Device registered with major number %d\n", ret);
    return 0;
}

static void __exit mydevice_exit(void) {
    unregister_chrdev(0, DEVICE_NAME);
    printk(KERN_INFO "Device unregistered\n");
}

module_init(mydevice_init);
module_exit(mydevice_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Simple IOCTL Example");

2. proc文件系统
proc文件系统是一个虚拟文件系统，用于与内核和进程相关的信息交换。驱动程序可以在/proc文件系统中创建文件，用户空间程序可以通过读写这些文件与驱动程序交互。

示例
内核驱动程序：

#include <linux/module.h>
#include <linux/proc_fs.h>
#include <linux/uaccess.h>

#define PROC_NAME "myprocfile"
#define BUFFER_SIZE 128

static char proc_buffer[BUFFER_SIZE];
static unsigned long proc_buffer_size = 0;

ssize_t proc_read(struct file *file, char __user *buf, size_t count, loff_t *pos) {
    if (*pos > 0 || count < proc_buffer_size) {
        return 0;
    }

    if (copy_to_user(buf, proc_buffer, proc_buffer_size)) {
        return -EFAULT;
    }

    *pos = proc_buffer_size;
    return proc_buffer_size;
}

ssize_t proc_write(struct file *file, const char __user *buf, size_t count, loff_t *pos) {
    if (count > BUFFER_SIZE) {
        proc_buffer_size = BUFFER_SIZE;
    } else {
        proc_buffer_size = count;
    }

    if (copy_from_user(proc_buffer, buf, proc_buffer_size)) {
        return -EFAULT;
    }

    return proc_buffer_size;
}

static struct file_operations proc_fops = {
    .owner = THIS_MODULE,
    .read = proc_read,
    .write = proc_write,
};

static int __init mymodule_init(void) {
    proc_create(PROC_NAME, 0666, NULL, &proc_fops);
    printk(KERN_INFO "/proc/%s created\n", PROC_NAME);
    return 0;
}

static void __exit mymodule_exit(void) {
    remove_proc_entry(PROC_NAME, NULL);
    printk(KERN_INFO "/proc/%s removed\n", PROC_NAME);
}

module_init(mymodule_init);
module_exit(mymodule_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Simple ProcFS Example");

用户空间程序：

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define PROC_FILE "/proc/myprocfile"

int main() {
    int fd = open(PROC_FILE, O_RDWR);
    if (fd < 0) {
        perror("Failed to open proc file");
        return 1;
    }

    char write_buffer[] = "Hello, proc!";
    if (write(fd, write_buffer, strlen(write_buffer)) < 0) {
        perror("Failed to write to proc file");
        close(fd);
        return 1;
    }

    char read_buffer[128];
    if (lseek(fd, 0, SEEK_SET) < 0) {
        perror("Failed to seek proc file");
        close(fd);
        return 1;
    }

    if (read(fd, read_buffer, sizeof(read_buffer) - 1) < 0) {
        perror("Failed to read from proc file");
        close(fd);
        return 1;
    }

    printf("Read from proc file: %s\n", read_buffer);
    close(fd);
    return 0;
}

3. sysfs文件系统
sysfs文件系统是一个虚拟文件系统，通常用于导出内核对象及其属性。驱动程序可以在/sys文件系统中创建文件，用户空间程序可以通过读写这些文件与驱动程序交互。

示例
内核驱动程序：

#include <linux/module.h>
#include <linux/kobject.h>
#include <linux/sysfs.h>
#include <linux/uaccess.h>

#define BUFFER_SIZE 128

static char sysfs_buffer[BUFFER_SIZE];
static struct kobject *example_kobj;

ssize_t sysfs_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf) {
    return sprintf(buf, "%s\n", sysfs_buffer);
}

ssize_t sysfs_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count) {
    snprintf(sysfs_buffer, BUFFER_SIZE, "%s", buf);
    return count;
}

static struct kobj_attribute example_attr = __ATTR(example, 0664, sysfs_show, sysfs_store);

static int __init example_init(void) {
    int retval;

    example_kobj = kobject_create_and_add("example", kernel_kobj);
    if (!example_kobj) {
        return -ENOMEM;
    }

    retval = sysfs_create_file(example_kobj, &example_attr.attr);
    if (retval) {
        kobject_put(example_kobj);
    }

    return retval;
}

static void __exit example_exit(void) {
    kobject_put(example_kobj);
}

module_init(example_init);
module_exit(example_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Simple SysFS Example");

用户空间程序：

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

#define SYSFS_FILE "/sys/kernel/example/example"

int main() {
    int fd = open(SYSFS_FILE, O_RDWR);
    if (fd < 0) {
        perror("Failed to open sysfs file");
        return 1;
    }

    char write_buffer[] = "Hello, sysfs!";
    if (write(fd, write_buffer, strlen(write_buffer)) < 0) {
        perror("Failed to write to sysfs file");
        close(fd);
        return 1;
    }

    char read_buffer[128];
    if (lseek(fd, 0, SEEK_SET) < 0) {
        perror("Failed to seek sysfs file");
        close(fd);
        return 1;
    }

    if (read(fd, read_buffer, sizeof(read_buffer) - 1) < 0) {
        perror("Failed to read from sysfs file");
        close(fd);
        return 1;
    }

    printf("Read from sysfs file: %s\n", read_buffer);
    close(fd);
    return 0;
}

4. Netlink套接字
Netlink套接字是用于用户空间和内核空间之间传递信息的机制，特别适用于复杂的消息传递和配置。

示例
内核驱动程序：

#include <linux/module.h>
#include <linux/netlink.h>
#include <net/sock.h>

#define NETLINK_USER 31

struct sock *nl_sk = NULL;

static void nl_recv_msg(struct sk_buff *skb) {
    struct nlmsghdr *nlh;
    char *msg = "Hello from kernel";
    struct sk_buff *skb_out;
    int msg_size;
    int res;

    nlh = (struct nlmsghdr *)skb->data;
    printk(KERN_INFO "Netlink received msg payload:%s\n", (char *)nlmsg_data(nlh));

    msg_size = strlen(msg);
    skb_out = nlmsg_new(msg_size, 0);
    if (!skb_out) {
        printk(KERN_ERR "Failed to allocate new skb\n");
        return;
    }

    nlh = nlmsg_put(skb_out, 0, 0, NLMSG_DONE, msg_size, 0);
    NETLINK_CB(skb_out).dst_group = 0;
    strncpy(nlmsg_data(nlh), msg, msg_size);

    res = nlmsg_unicast(nl_sk, skb_out, nlh->nlmsg_pid);
    if (res < 0) {
        printk(KERN_INFO "Error while sending back to user\n");
    }
}

static int __init hello_init(void) {
    struct netlink_kernel_cfg cfg = {
        .input = nl_recv_msg,
    };

    nl_sk = netlink_kernel_create(&init_net, NETLINK_USER, &cfg);
    if (!nl_sk) {
        printk(KERN_ALERT "Error creating socket.\n");
        return -10;
    }

    return 0;
}

static void __exit hello_exit(void) {
    netlink_kernel_release(nl_sk);
}

module_init(hello_init);
module_exit(hello_exit);

MODULE_LICENSE("GPL");

用户空间程序：

#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/netlink.h>

#define NETLINK_USER 31

struct sockaddr_nl src_addr, dest_addr;
struct nlmsghdr *nlh = NULL;
struct iovec iov;
int sock_fd;
struct msghdr msg;

int main() {
    sock_fd = socket(PF_NETLINK, SOCK_RAW, NETLINK_USER);
    if (sock_fd < 0) {
        return -1;
    }

    memset(&src_addr, 0, sizeof(src_addr));
    src_addr.nl_family = AF_NETLINK;
    src_addr.nl_pid = getpid(); // Self pid

    bind(sock_fd, (struct sockaddr *)&src_addr, sizeof(src_addr));

    memset(&dest_addr, 0, sizeof(dest_addr));
    dest_addr.nl_family = AF_NETLINK;
    dest_addr.nl_pid = 0; // For Linux Kernel
    dest_addr.nl_groups = 0; // unicast

    nlh = (struct nlmsghdr *)malloc(NLMSG_SPACE(1024));
    memset(nlh, 0, NLMSG_SPACE(1024));
    nlh->nlmsg_len = NLMSG_SPACE(1024);
    nlh->nlmsg_pid = getpid();
    nlh->nlmsg_flags = 0;

    strcpy(NLMSG_DATA(nlh), "Hello from user");

    iov.iov_base = (void *)nlh;
    iov.iov_len = nlh->nlmsg_len;
    msg.msg_name = (void *)&dest_addr;
    msg.msg_namelen = sizeof(dest_addr);
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;

    sendmsg(sock_fd, &msg, 0);

    // Read message from kernel
    recvmsg(sock_fd, &msg, 0);
    printf("Received message payload: %s\n", (char *)NLMSG_DATA(nlh));

    close(sock_fd);
    return 0;
}

5. 共享内存
共享内存是一种高效的数据传递方式，用户空间程序和内核驱动程序可以通过共享内存区域交换数据。通常使用mmap系统调用在用户空间和内核空间之间创建共享内存区域。

示例
内核驱动程序：

#include <linux/module.h>
#include <linux/mm.h>
#include <linux/fs.h>
#include <linux/uaccess.h>

#define DEVICE_NAME "shmdevice"
#define BUFFER_SIZE 4096

static char *shared_buffer;
static int major_number;

static int device_mmap(struct file *file, struct vm_area_struct *vma) {
    unsigned long pfn = virt_to_phys(shared_buffer) >> PAGE_SHIFT;
    size_t size = vma->vm_end - vma->vm_start;

    if (size > BUFFER_SIZE) {
        return -EINVAL;
    }

    return remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot);
}

static struct file_operations fops = {
    .mmap = device_mmap,
};

static int __init shmdevice_init(void) {
    major_number = register_chrdev(0, DEVICE_NAME, &fops);
    if (major_number < 0) {
        printk(KERN_ALERT "Failed to register character device\n");
        return major_number;
    }

    shared_buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);
    if (!shared_buffer) {
        unregister_chrdev(major_number, DEVICE_NAME);
        return -ENOMEM;
    }

    printk(KERN_INFO "Shared memory device initialized\n");
    return 0;
}

static void __exit shmdevice_exit(void) {
    kfree(shared_buffer);
    unregister_chrdev(major_number, DEVICE_NAME);
    printk(KERN_INFO "Shared memory device removed\n");
}

module_init(shmdevice_init);
module_exit(shmdevice_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("An Example Author");
MODULE_DESCRIPTION("A Shared Memory Example");

用户空间程序：

#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

#define DEVICE_FILE "/dev/shmdevice"
#define BUFFER_SIZE 4096

int main() {
    int fd = open(DEVICE_FILE, O_RDWR);
    if (fd < 0) {
        perror("Failed to open device file");
        return 1;
    }

    char *shared_mem = mmap(NULL, BUFFER_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (shared_mem == MAP_FAILED) {
        perror("Failed to mmap");
        close(fd);
        return 1;
    }

    strcpy(shared_mem, "Hello from user space!");

    printf("Read from shared memory: %s\n", shared_mem);

    munmap(shared_mem, BUFFER_SIZE);
    close(fd);
    return 0;
}

总结
除了设备文件缓存之外，还有多种方法可以在用户空间程序和内核驱动程序之间传递或存储数据。选择哪种方法取决于具体的应用场景、数据类型和性能需求。常见的方法包括：

ioctl: 用于发送控制命令和数据，灵活且通用。
proc文件系统: 适用于简单的配置和状态信息交换。
sysfs文件系统: 适用于导出内核对象及其属性。
Netlink套接字: 适用于复杂的消息传递和配置。
共享内存: 提供高效的数据传递方式，适用于大数据量的交换。
这些方法提供了丰富的工具，允许用户空间程序和内核驱动程序之间进行高效、安全和灵活的通信。
===================================================================================================

以下是合并后的完整字符设备驱动程序代码，包含打开、关闭、读、写以及 poll 操作的实现：

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/poll.h>
#include <linux/wait.h>
#include <linux/device.h>

#define DEVICE_NAME "mychardev"
#define BUFFER_SIZE 1024

static int major_number;
static char device_buffer[BUFFER_SIZE];
static int buffer_size = 0;
static wait_queue_head_t device_wait_queue;
static int device_open_count = 0;
static struct class *device_class;
static struct device *device_object;

static int device_open(struct inode *, struct file *);
static int device_release(struct inode *, struct file *);
static ssize_t device_read(struct file *, char __user *, size_t, loff_t *);
static ssize_t device_write(struct file *, const char __user *, size_t, loff_t *);
static unsigned int device_poll(struct file *, poll_table *);

static struct file_operations fops = {
    .owner = THIS_MODULE,
    .open = device_open,
    .release = device_release,
    .read = device_read,
    .write = device_write,
    .poll = device_poll,
};

static int device_open(struct inode *inode, struct file *file) {
    if (device_open_count) {
        return -EBUSY;
    }
    device_open_count++;
    try_module_get(THIS_MODULE);
    return 0;
}

static int device_release(struct inode *inode, struct file *file) {
    device_open_count--;
    module_put(THIS_MODULE);
    return 0;
}

static ssize_t device_read(struct file *file, char __user *user_buffer, size_t count, loff_t *offset) {
    int bytes_to_read = min(count, (size_t)buffer_size);
    if (bytes_to_read == 0) {
        return 0;
    }

    if (copy_to_user(user_buffer, device_buffer, bytes_to_read) != 0) {
        return -EFAULT;
    }

    buffer_size = 0;
    return bytes_to_read;
}

static ssize_t device_write(struct file *file, const char __user *user_buffer, size_t count, loff_t *offset) {
    int bytes_to_write = min(count, (size_t)(BUFFER_SIZE - buffer_size));
    if (bytes_to_write == 0) {
        return -ENOMEM;
    }

    if (copy_from_user(device_buffer, user_buffer, bytes_to_write) != 0) {
        return -EFAULT;
    }

    buffer_size = bytes_to_write;
    wake_up_interruptible(&device_wait_queue); // 唤醒等待队列中的进程
    return bytes_to_write;
}

static unsigned int device_poll(struct file *file, poll_table *wait) {
    unsigned int mask = 0;

    poll_wait(file, &device_wait_queue, wait);

    if (buffer_size > 0) {
        mask |= POLLIN | POLLRDNORM;
    }

    if (buffer_size < BUFFER_SIZE) {
        mask |= POLLOUT | POLLWRNORM;
    }

    return mask;
}

static int __init device_init(void) {
    major_number = register_chrdev(0, DEVICE_NAME, &fops);
    if (major_number < 0) {
        printk(KERN_ALERT "Failed to register a major number\n");
        return major_number;
    }

    device_class = class_create(THIS_MODULE, DEVICE_NAME);
    if (IS_ERR(device_class)) {
        unregister_chrdev(major_number, DEVICE_NAME);
        printk(KERN_ALERT "Failed to register device class\n");
        return PTR_ERR(device_class);
    }

    device_object = device_create(device_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
    if (IS_ERR(device_object)) {
        class_destroy(device_class);
        unregister_chrdev(major_number, DEVICE_NAME);
        printk(KERN_ALERT "Failed to create the device\n");
        return PTR_ERR(device_object);
    }

    init_waitqueue_head(&device_wait_queue);

    printk(KERN_INFO "Device initialized: %s with major number %d\n", DEVICE_NAME, major_number);
    return 0;
}

static void __exit device_exit(void) {
    device_destroy(device_class, MKDEV(major_number, 0));
    class_unregister(device_class);
    class_destroy(device_class);
    unregister_chrdev(major_number, DEVICE_NAME);
    printk(KERN_INFO "Device exited: %s\n", DEVICE_NAME);
}

module_init(device_init);
module_exit(device_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("A simple character device driver with poll support");
MODULE_VERSION("1.0");

代码说明
头文件和宏定义：包含了所需的头文件和一些宏定义。
全局变量：定义了设备缓冲区、等待队列、设备打开计数等。
文件操作函数原型和实现：
device_open：处理设备文件的打开。
device_release：处理设备文件的关闭。
device_read：处理从设备读取数据。
device_write：处理向设备写入数据。
device_poll：处理 poll 系统调用，使得设备支持非阻塞I/O和多路复用。
模块初始化和退出函数：
device_init：注册字符设备并创建设备类和设备对象。
device_exit：销毁设备对象和设备类，并注销字符设备。
通过这些代码，您可以创建一个支持 poll 操作的简单字符设备驱动程序。应用程序可以使用 poll、select 或 epoll 等系统调用来监视设备文件描述符的状态，从而实现非阻塞和多路复用的I/O操作。
===================================================================================================

gcc -o example example.c $(pkg-config --cflags --libs libevent)

"args": ["-H", "localhost", "-s", "127.0.0.1:12345"],


select能得到fd的哪些状态

select 系统调用用于监视多个文件描述符，并等待这些文件描述符中的一个或多个变为可读、可写或有异常条件发生。通过 select，你可以得到以下几种文件描述符的状态：

可读状态（readable）： 如果文件描述符变为可读，意味着你可以从该文件描述符中读取数据而不会阻塞。这通常用于监视输入操作，例如：

文件、管道或终端中有数据可供读取。
网络套接字（TCP/UDP）中有数据到达。
可写状态（writable）： 如果文件描述符变为可写，意味着你可以向该文件描述符写入数据而不会阻塞。这通常用于监视输出操作，例如：

文件或管道可以接收数据写入。
网络套接字（TCP/UDP）可以发送数据。
异常状态（exceptional condition）： 如果文件描述符有异常条件发生，例如带外数据（Out-of-band data）到达。这通常用于监视特殊情况，例如：

网络套接字上有带外数据到达（TCP 紧急数据）。
select 的参数
select 函数的原型如下：

int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);

参数解释：

nfds：监视的文件描述符数量，即待监视的最大文件描述符加 1。
readfds：指向包含待监视的可读文件描述符集合的 fd_set 结构。
writefds：指向包含待监视的可写文件描述符集合的 fd_set 结构。
exceptfds：指向包含待监视的异常文件描述符集合的 fd_set 结构。
timeout：指向一个 timeval 结构，指定等待的超时时间。如果为 NULL，select 将无限期阻塞，直到监视的文件描述符之一发生状态变化。
使用示例
以下是一个使用 select 来监视文件描述符的示例，监视其可读、可写和异常状态：

#include <sys/select.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    fd_set read_fds, write_fds, except_fds;
    struct timeval timeout;
    int fd;
    char buffer[256];
    int retval;

    // 打开文件描述符
    fd = open("/tmp/testfile", O_RDWR);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // 初始化文件描述符集合
    FD_ZERO(&read_fds);
    FD_ZERO(&write_fds);
    FD_ZERO(&except_fds);

    // 添加文件描述符到集合
    FD_SET(fd, &read_fds);
    FD_SET(fd, &write_fds);
    FD_SET(fd, &except_fds);

    // 设置超时时间
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;

    // 调用 select 函数
    // 监视3个fd集合
    retval = select(fd + 1, &read_fds, &write_fds, &except_fds, &timeout);
    if (retval == -1) {
        perror("select");
        exit(EXIT_FAILURE);
    } else if (retval == 0) {
        printf("Timeout occurred! No data within five seconds.\n");
    } else {//集合中有fd状态变化
        if (FD_ISSET(fd, &read_fds)) {//如果fd在可读集合，读取数据
            printf("File descriptor %d is ready to read\n", fd);
            read(fd, buffer, sizeof(buffer));
            printf("Read data: %s\n", buffer);
        }

        if (FD_ISSET(fd, &write_fds)) {//如果fd在可写集合，写入数据
            printf("File descriptor %d is ready to write\n", fd);
            write(fd, "Hello, world!", 13);
        }

        if (FD_ISSET(fd, &except_fds)) {//如果fd在异常集合，处理异常
            printf("File descriptor %d has an exceptional condition\n", fd);
        }
    }

    close(fd);
    return 0;
}


epoll怎么用，它能监视fd的哪些状态

epoll 是 Linux 特有的高效 I/O 多路复用机制，可以高效地监视大量文件描述符。epoll 通过事件驱动模型和持久化的事件集合，解决了 select 和 poll 的性能问题。

epoll 基本使用方法
epoll 提供了三个主要的系统调用：

epoll_create1：创建一个 epoll 实例。
epoll_ctl：控制 epoll 实例，添加、修改或删除文件描述符。
epoll_wait：等待文件描述符上的事件。
示例代码
以下是一个使用 epoll 的简单示例：
#include <sys/epoll.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

#define MAX_EVENTS 10

int main() {
    int epoll_fd, fd;
    struct epoll_event event, events[MAX_EVENTS];
    char buffer[256];

    // 创建一个 epoll 实例
    epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) {
        perror("epoll_create1");
        exit(EXIT_FAILURE);
    }

    // 打开文件描述符
    fd = open("/tmp/testfile", O_RDWR | O_NONBLOCK);
    if (fd == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }

    // 设置 epoll 事件类型，监视所有状态
    event.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP | EPOLLPRI | EPOLLERR | EPOLLHUP | EPOLLET;
    event.data.fd = fd;

    // 将文件描述符添加到 epoll 实例
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &event) == -1) {
        perror("epoll_ctl");
        exit(EXIT_FAILURE);
    }

    while (1) {
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) {
            perror("epoll_wait");
            exit(EXIT_FAILURE);
        }

        for (int i = 0; i < nfds; ++i) {
            if (events[i].events & EPOLLIN) {
                // 处理读取事件
                ssize_t count = read(events[i].data.fd, buffer, sizeof(buffer));
                if (count == -1) {
                    perror("read");
                    exit(EXIT_FAILURE);
                } else if (count == 0) {
                    printf("EOF\n");
                    close(events[i].data.fd);
                } else {
                    printf("Read %zd bytes: %.*s\n", count, (int)count, buffer);
                }
            }

            if (events[i].events & EPOLLOUT) {
                // 处理写入事件
                printf("File descriptor %d is ready to write\n", events[i].data.fd);
                ssize_t count = write(events[i].data.fd, "Hello, world!", 13);
                if (count == -1) {
                    perror("write");
                    exit(EXIT_FAILURE);
                } else {
                    printf("Wrote %zd bytes\n", count);
                }
            }

            if (events[i].events & EPOLLRDHUP) {
                // 处理对端关闭事件
                printf("Peer closed connection on file descriptor %d\n", events[i].data.fd);
                close(events[i].data.fd);
            }

            if (events[i].events & EPOLLPRI) {
                // 处理紧急数据事件
                printf("File descriptor %d has urgent data available\n", events[i].data.fd);
                ssize_t count = read(events[i].data.fd, buffer, sizeof(buffer));
                if (count == -1) {
                    perror("read");
                    exit(EXIT_FAILURE);
                } else {
                    printf("Read %zd urgent bytes: %.*s\n", count, (int)count, buffer);
                }
            }

            if (events[i].events & EPOLLERR) {
                // 处理错误事件
                printf("File descriptor %d has encountered an error\n", events[i].data.fd);
                close(events[i].data.fd);
            }

            if (events[i].events & EPOLLHUP) {
                // 处理挂起事件
                printf("File descriptor %d has been hung up\n", events[i].data.fd);
                close(events[i].data.fd);
            }
        }
    }

    close(epoll_fd);
    return 0;
}

epoll 能监视的文件描述符状态
epoll 可以监视多种文件描述符状态，使用 epoll_event 结构体中的 events 字段来指定感兴趣的事件类型。常用的事件类型包括：

EPOLLIN：表示对应的文件描述符可以读取数据（包括普通文件、管道、网络套接字等）。
EPOLLOUT：表示对应的文件描述符可以写入数据。
EPOLLRDHUP：表示对端关闭连接或半关闭（常用于套接字）。
EPOLLPRI：表示有紧急数据可读（常用于带外数据）。
EPOLLERR：表示对应的文件描述符发生错误。
EPOLLHUP：表示对应的文件描述符挂起事件。
EPOLLET：将文件描述符设置为边缘触发模式（Edge Triggered）。
EPOLLONESHOT：将文件描述符设置为一次性事件（一次触发后需要重新设置）。

边缘触发模式和水平触发模式的区别：
比如EPOLLIN 边缘触发只会在数据到达时触发一次，如果你只从缓存区读取一半数据，后续并不会再触发了（除非再有数据到达），而水平触发则是只要缓存区还有数据，它将一直触发
所以在边缘触发处理 EPOLLIN 或 EPOLLOUT 事件时，应尽可能多地读取或写入数据，直到返回 EAGAIN（表示没有更多数据可读或写入缓冲区满）。
以下是示例
for (int i = 0; i < nfds; ++i) {
            if (events[i].events & EPOLLIN) {
                while (1) {
                    char buffer[128];
                    struct sockaddr_in client_addr;
                    socklen_t addr_len = sizeof(client_addr);

                    ssize_t bytesRead = recvfrom(events[i].data.fd, buffer, sizeof(buffer) - 1, 0,
                                                 (struct sockaddr*)&client_addr, &addr_len);
                    if (bytesRead == -1) {
                        if (errno == EAGAIN || errno == EWOULDBLOCK) {
                            // 没有更多数据可读
                            break;
                        } else {
                            perror("recvfrom");
                            close(events[i].data.fd);
                            break;
                        }
                    } else {
                        buffer[bytesRead] = '\0';
                        printf("Received data: %s\n", buffer);

                        // 回复客户端
                        const char* reply = "Data received";
                        ssize_t bytesSent = sendto(events[i].data.fd, reply, strlen(reply), 0,
                                                   (struct sockaddr*)&client_addr, addr_len);
                        if (bytesSent == -1) {
                            perror("sendto");
                        }
                    }
                }
            }
        }

epoll 相关系统调用
epoll_create1：

int epoll_create1(int flags);

创建一个新的 epoll 实例，并返回一个文件描述符。flags 参数通常为 0 或 EPOLL_CLOEXEC。

epoll_ctl：

int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

控制 epoll 实例，执行添加、删除或修改操作。

epfd：epoll 实例的文件描述符。
op：操作类型，可以是 EPOLL_CTL_ADD、EPOLL_CTL_MOD 或 EPOLL_CTL_DEL。
fd：要操作的文件描述符。
event：指向 epoll_event 结构体的指针。
epoll_wait：

int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

等待事件发生，并返回已触发事件的数量。

epfd：epoll 实例的文件描述符。
events：指向 epoll_event 数组的指针，用于返回已触发的事件。
maxevents：events 数组的大小。
timeout：超时时间，以毫秒为单位。若为 -1，则无限等待。
总结
epoll 提供了高效的 I/O 多路复用机制，适用于处理大量并发连接的高性能服务器。通过 epoll_create1 创建 epoll 实例，使用 epoll_ctl 进行文件描述符的添加、删除和修改操作，并通过 epoll_wait 等待文件描述符上的事件发生。epoll 可以监视多种文件描述符状态，包括可读、可写、异常等，特别适合高并发和高性能的网络应用场景。
===================================================================================================
epoll和udp

对于 UDP 套接字（文件描述符，fd），某些 epoll 事件标志比其他标志更有用。让我们分别看一下这些标志，以及它们在 UDP 套接字中的适用性：

EPOLLIN：表示有数据可读。这对于接收 UDP 数据报文是非常有用的。当有新的数据报文到达时，会触发这个事件。

EPOLLOUT：表示可以发送数据。这对于发送 UDP 数据报文是有用的。对于大多数情况，UDP 套接字总是可以发送数据，因为它是无连接的，但在某些情况下（例如，系统缓冲区满了），这个事件可能会变得有用。

EPOLLRDHUP：表示对端关闭连接。这个事件在 UDP 套接字中通常没有意义，因为 UDP 是无连接的协议，没有连接关闭的概念。

EPOLLPRI：表示有紧急数据可读。这个事件对于 UDP 套接字来说通常不常见，因为紧急数据（带外数据）主要用于 TCP 套接字。

EPOLLERR：表示发生错误。这个事件对于所有类型的套接字都是有用的，包括 UDP。当套接字发生错误（例如，网络错误）时，会触发这个事件。

EPOLLHUP：表示挂起/挂断。对于 UDP 套接字，这种情况很少见，但可能在某些罕见的错误情况下发生。

EPOLLET：表示使用边缘触发模式。这对所有类型的套接字都适用，包括 UDP。边缘触发模式可以提高性能，但需要更加小心地处理，以确保不会错过任何事件。
===================================================================================================
在使用 epoll 时，判断对端 socket 是否关闭通常通过 read 函数返回值来实现。以下是具体的方法：

read 返回值为 0: 当 read 函数返回 0 时，表示对端 socket 已经正常关闭连接。这是 TCP 连接中对端执行 close 操作的标志。

read 返回 -1 并且 errno 为 EAGAIN 或 EWOULDBLOCK: 这表示当前没有数据可读，但连接仍然是打开的。需要继续等待数据。

read 返回 -1 并且 errno 为其他错误: 这通常表示发生了某种错误，可以选择关闭连接。
===================================================================================================

g++ -c -g simple_event_array.cc -o simple_event_array.o
gcc -c -g simple_event.c  -o simple_event.o
gcc -c -g simple_event_test.c  -o simple_event_test.o
g++ simple_event.o simple_event_test.o simple_event_array.o -o stest

g++ simple_event_array.cc simple_event_test.c simple_event.c -o ptest

rm -rf CMakeFiles/ CMakeCache.txt
cmake -DCMAKE_C_COMPILER=/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc -DCMAKE_BUILD_TYPE=Release .
/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-strip my_client
./my_client 23456 192.168.100.124 12345

/media/tcp_test 1 10 161.189.165.150 19011
/media/tcp_test 1 10 192.168.100.253 19011

/media/tcp_test 1 10 161.189.165.150 19011
/media/tcp_test 1 10 161.189.165.150 19011
/media/sev_net_test_cli_arm 23456 161.189.165.150 12345

wpa_supplicant -B -Dnl80211 -iwlan0 -c/etc/wpa_supplicant.conf

wpa_cli -i wlan0 add_network
wpa_cli -i wlan0 set_network 0 ssid '"HUAWEI_B311_3C8C"'
wpa_cli -i wlan0 set_network 0 psk '"55556666@11"'
wpa_cli -i wlan0 select_network 0 
wpa_cli -i wlan0 enable_network 0 
udhcpc -iwlan0

/media/sev_quic_cli_arm3 23456 192.168.0.111 12345
/media/sev_quic_cli_arm1 23456 192.168.0.111 12345


./echo_server -s 127.0.0.1:12345
./echo_client -H localhost -s 127.0.0.1:12345

/mnt/hgfs/share/lsquic_full/lsquic_mini_v2/quic# ./sev_net_test_svr_x86 12345
/media/libquic_test_arm 23456 192.168.0.111 12345

#repo 清理未跟踪及修改
repo forall -c 'git reset --hard && git clean -fd'

使用 repo list 命令可以列出所有仓库及其路径，找到目标仓库的路径。

某个命令的所有输出都到某个文件中
cmd &> log.txt

apt-get install build-essential subversion git-core libncurses5-dev zlib1g-dev gawk flex quilt libssl-dev xsltproc libxml-parser-perl mercurial bzr ecj cvs unzip lib32z1 lib32z1-dev lib32stdc++6 libstdc++6 -y libc6:i386 libstdc++6:i386 lib32ncurses5 lib32z1
apt-get install build-essential subversion git-core libncurses5-dev zlib1g-dev gawk flex quilt libssl-dev xsltproc libxml-parser-perl mercurial bzr ecj cvs unzip lib32z1 lib32z1-dev lib32stdc++6 libstdc++6 -y libc6:i386 libstdc++6:i386 lib32z1

/home/mars/workspace/code/qzsdk/cross_compiler/toolchain/bin/arm-openwrt-linux-gcc 

使用power shell从windows拷贝文件到linux
scp "C:\share\speed_test_svr.c" puwell@161.189.165.150:/home/puwell/ipc_service/speed_test

scp C:\AMTAG.BIN  root@192.168.23.128:/extern/test

root@192.168.23.128表示root用户用ssh方式连接192.168.23.128


使用 cp 命令结合通配符 {} 来减少重复输入路径进行拷贝
cp /extern/dir/path/{A,B,C} .

===================================================================================================
你也可以通过查看进程列表来检查服务是否在运行：

使用 ps 命令结合 grep：
ps aux | grep <service_name>

例如：
ps aux | grep nginx

这将显示所有与nginx相关的进程。如果看到相关条目，说明服务正在运行。
使用 pgrep 命令
pgrep 命令可以直接查找进程 ID：

使用 pgrep 命令：
pgrep <service_name>

例如：
pgrep nginx

如果返回一个或多个进程 ID，说明服务正在运行。
使用 netstat 或 ss 命令
如果你知道服务监听的端口，可以通过查看端口是否被监听来确定服务是否在运行：

使用 netstat 命令：

sudo netstat -tuln | grep <port _number>

例如，检查nginx是否在监听80端口：

sudo netstat -tuln | grep 80

使用 ss 命令：

sudo ss -tuln | grep <port_number>

例如：

sudo ss -tuln | grep 80

===================================================================================================
speed_test_cli 1 100 161.189.165.150 8987

/home/puwell/ipc_service/speed_test
./run_speed_test_svr_10_minute.sh

===================================================================================================
1. CONFIG_SUPPORT_PACK_OUT_OF_TINA
2. .config 
3.

===================================================================================================
临时设置 LD_LIBRARY_PATH（只对当前终端有效）
export LD_LIBRARY_PATH=/opt/openssl-1.0.2u/lib:$LD_LIBRARY_PATH

./sdkTest --user 15988184546 --passwd puwell119 --ipc sh.ipc365.com


 -D_USE_MP4 -Dxprint\(fmt\,...\)=printf\(\"\%s:\"\"\#\#mp4\#\#\ \"fmt\"\\n\"\,__func__\,\#\#__VA_ARGS__\)

 /media/simu_quic_arm 23456 192.168.0.111 12345 66000

 mkdir /tmp/nfs_share
 mount -o vers=4 192.168.0.111:/home/mars/nfs_share /tmp/nfs_share

 cp output/demo_rtsp $nfss/demo_rtsp_viveset 
demo_rtsp相关
需把html资源./platform/partition/to_rootfs/rtsp_conf/www拷贝到/mnt/extsd/   
启动前udhcpc获取ip地址
web控制 浏览器直接访问ip
vlc看流rtsp://ip:8554/ch0

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/media/net_capture
/media/net_capture/tcpdump -i wlan0 -w /media/net_capture/capture.pcap &
/media/net_capture/tcpdump -i eth0 -w /media/net_capture/capture.pcap &
ll /media/net_capture/capture.pcap

视频分析eseye_u.exe

注意用tcp时只用一个流
zrt_app_native 原生 tcp 外网
zrt_app_tcp_que tcp 外网 que
zrt_app_tcp142 tcp 142 que

/extern/v821/prebuilt/rootfsbuilt/riscv/nds32le-linux-musl-v5d/bin/riscv32-linux-musl-g++  -o HalNN  HalNN.c -I ./ -I ./include -I lib_aw/include/eyesee-mpp/middleware/include/media/ -I lib_aw/include/eyesee-mpp/middleware/include/utils/ -I lib_aw/include/eyesee-mpp/middleware/media/include/ -I lib_aw/include/eyesee-mpp/middleware/media/include/component/ -I lib_aw/include/eyesee-mpp/middleware/media/include/utils/ -I lib_aw/include/eyesee-mpp/middleware/media/LIBRARY/libisp/include/V4l2Camera/ -I lib_aw/include/eyesee-mpp/middleware/media/LIBRARY/libisp/include/ -I lib_aw/include/eyesee-mpp/middleware/media/LIBRARY/libisp/isp_tuning/ -I lib_aw/include/eyesee-mpp/middleware/media/LIBRARY/libisp/ -I lib_aw/include/eyesee-mpp/middleware/media/LIBRARY/libisp/include/device/ -I lib_aw/include/libcedarc/include/ -I lib_aw/include/libcedarc/base/include/ -I person_detection/src/include/ -I person_detection/src/3rdparty/include/  -L./lib_aw/lib/  -L./lib_aw/lib/eyesee-mpp/   -L./lib_aw/lib/libcedarc/   -L./lib_aw/lib/awion/  -L./lib_aw/lib/expat/  -L./person_detection/src/lib/musl/ -L./person_detection/src/3rdparty/lib/musl -law_mpp -llog  -lmedia_utils -ladecoder -lwav -lcedarx_aencoder -lAgc -lAns -lAec  -lResample -lAudioVps -lvencoder -lcdc_base -lcdc_base -lexpat -lvenc_base -lvenc_common -lMemAdapter -lcdc_base -lVE -lvenc_h264 -lvenc_jpeg -lISP -lisp_dev -lisp_ini -liniparser -lisp_ae -lisp_af -lisp_afs -lisp_awb -lisp_base -lisp_gtm -lisp_iso -lisp_math -lisp_md -lisp_pltm -lisp_rolloff -lawion -lcdc_base -lvenc_h264 -lVE -lvenc_base -lvenc_jpeg -lvenc_h264 -lvenc_common  -law_utilities_standalone_v821 -law_person_det_nn_v821 -law_person_det_v821 -lnn_p -lnn_qt_dq_p -lasound -lglog 

make CXX=/extern/v821/prebuilt/rootfsbuilt/riscv/nds32le-linux-musl-v5d/bin/riscv32-linux-musl-g++ PERSON_DETECTION_LIBC=musl

-Wl,--start-group libA.a libB.a libC.a -Wl,--end-group

链接器会将 libA.a、libB.a 和 libC.a 作为一个组进行多次扫描，确保所有符号依赖都被正确解析。

/extern/v821/prebuilt/rootfsbuilt/riscv/nds32le-linux-musl-v5d/bin/riscv32-linux-musl-nm src/device_tina/pdet/src/lib/glibc/libnn_qt_dq_p.a | grep riscv_nn_dequantize_s8_f32

cat /proc/mtd 查看各个分区大小

修改了make menuconfig之后需要
./build config

clock_gettime(CLOCK_REALTIME, &ts);
gettimeofday



            ZRT_SYS_CmdCall("rm -rf /media/temp");
            ZRT_SYS_CmdCall("mkdir /media/temp");
            ZRT_SYS_CmdCall("cp /var/log/* /config/cfg.txt /config/default_cfg.txt /media/temp");
            ZRT_SYS_CmdCall("sync");


export LD_LIBRARY_PATH=/media:$LD_LIBRARY_PATH
cat /sys/kernel/debug/mpp/vi

copy /y zrt_app D:\
copy /y C:\share\lightning_port\zrt_app D:\

/usr/bin/check_stream.sh > /media/log/stream_dump.txt

print_SD_BIT 检查sdc卡状态

static struct Country_Router router_list[20] =
{
		//default ip
		{ "sh.ipc365.com",	"192.168.10.241"},
		{ "ca.ipc365.com",	"192.168.10.241"},
		{ "ru.ipc365.com",	"192.168.10.241"},
		{ "fr.ipc365.com",	"192.168.10.241"},
		{ "sp.ipc365.com",	"192.168.10.241"},
		{ "sg.ipc365.com",	"192.168.10.241"},
		{ "", ""}
};

1. 进入 nano 编辑器的界面
当你运行 svn commit 时，默认会打开 nano 编辑器，屏幕上会显示类似以下的内容：

--This line, and those below, will be ignored--

A    newfile.txt
M    modifiedfile.txt
D    deletedfile.txt
--This line, and those below, will be ignored--：表示这些行不会被作为提交日志的一部分。通常这些行会列出此次提交中新增（A）、修改（M）或删除（D）的文件，供你参考。
你可以在第一行开始输入你的提交日志。
2. 编辑提交日志
在 nano 编辑器中，直接输入你的提交信息。例如：

Fixing a bug in the login module.
Added error handling for empty username and password fields.
这段文字将作为你的提交日志，描述你这次提交的更改内容。

3. 保存并退出 nano
完成提交日志的编辑后，需要保存并退出 nano 编辑器。按照以下步骤操作：

保存文件：

按下 Ctrl + O（表示 "Write Out"，写入文件）。
屏幕底部会提示你保存的文件名（通常是临时文件名，例如 .svn-commit.tmp）。
直接按回车（Enter）确认。
退出编辑器：

按下 Ctrl + X（表示 "Exit"，退出编辑器）。
4. 完成提交
退出 nano 后，SVN 会自动读取提交日志并完成提交。你会看到类似以下的输出：

Sending        modifiedfile.txt
Adding         newfile.txt
Deleting       deletedfile.txt
Transmitting file data ...
Committed revision 123.
这表示提交成功，新的修订版本号是 123。

5. 如何避免进入 nano 编辑器
如果你不想每次都进入 nano 编辑器，可以在命令行中直接通过 -m 参数指定提交日志。例如：

svn commit -m "Fixing a bug in the login module."
这样，SVN 会直接使用你在 -m 参数中指定的提交日志，而不会打开 nano 编辑器。

ping: gerritsdk.allwinnertech.com: Temporary failure in name resolution  
这是dns解析失败，需要配置/etc/resolv.conf 
追加
nameserver 1.1.1.1
nameserver 8.8.8.8
